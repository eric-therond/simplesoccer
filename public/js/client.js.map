{"version":3,"sources":["client/AutoList.js","client/BaseGameEntity.js","client/ColorTeam.js","client/EntityManager.js","client/FieldPlayer.js","client/FieldPlayerStates.js","client/Goal.js","client/Goalkeeper.js","client/GoalkeeperStates.js","client/MessageDispatcher.js","client/MovingEntity.js","client/Params.js","client/PlayerBase.js","client/PrecisionTimer.js","client/Region.js","client/Regulator.js","client/SoccerBall.js","client/SoccerMessages.js","client/SoccerPitch.js","client/SoccerTeam.js","client/State.js","client/StateMachine.js","client/SteeringBehaviors.js","client/SupportSpotCalculator.js","client/TeamStates.js","client/Telegram.js","client/Transformations.js","client/Wall2D.js","client/gameBoot.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA1BA;AAAA;ACAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA5GA;AAAA;ACAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AARA;AAAA;ACAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAzCA;AAAA;ACAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAlLA;AAAA;ACAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AApuBA;AAAA;ACAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA3DA;AAAA;ACAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AApKA;AAAA;ACAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAzUA;AAAA;ACAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AArGA;AAAA;ACAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAhJA;AAAA;ACAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AApDA;AAAA;ACAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAlUA;AAAA;ACAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAtHA;AAAA;ACAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAnLA;AAAA;ACAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA7DA;AAAA;ACAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AApUA;AAAA;ACAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA3CA;AAAA;ACAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA/SA;AAAA;CCAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAnxBA;AAAA;ACAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAjBA;AAAA;ACAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA5GA;AAAA;ACAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAncA;AAAA;ACAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA5LA;AAAA;ACAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAnKA;AAAA;ACAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAfA;AAAA;ACAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAjFA;AAAA;ACAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAhEA;AAAA;ACAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAxEA;AAAA","file":"public/js/client.js","sourcesContent":["'use strict';\r\n\r\nclass AutoList\r\n{\r\n  constructor()\r\n  {\r\n    this.members = [];\r\n  }\r\n\r\n  push(member)\r\n  {\r\n    this.members.push(member);\r\n  }\r\n\r\n  GetAllMembers()\r\n  {\r\n    return this.members;\r\n  }\r\n}\r\n\r\nif (typeof ListMembers === 'undefined')\r\n{\r\n  var ListMembers = new AutoList();\r\n}\r\n\r\nmodule.exports.AutoList = ListMembers;\r\n","'use strict';\r\n\r\nvar m_iNextValidID = 0;\r\n\r\nvar entity_type = {\r\n  default_entity_type: -1,\r\n};\r\n\r\nclass BaseGameEntity\r\n{\r\n  constructor(id, game)\r\n  {\r\n    this.SetID(id);\r\n    this.m_dBoundingRadius = 0.0;\r\n    this.m_vScale = new Phaser.Point(1.0, 1.0);\r\n    this.m_iType = entity_type.default_entity_type;\r\n    this.m_bTag = false;\r\n    this.sprite = null;\r\n    this.game = game;\r\n\r\n  }\r\n\r\n  SetID(val)\r\n  {\r\n    this.m_ID = val;\r\n\r\n    m_iNextValidID = this.m_ID + 1;\r\n  }\r\n\r\n  ID()\r\n  {\r\n    return this.m_ID;\r\n  }\r\n\r\n  static GetNextValidID()\r\n  {\r\n    return m_iNextValidID;\r\n  }\r\n\r\n  ResetNextValidID()\r\n  {\r\n    m_iNextValidID = 0;\r\n  }\r\n\r\n  Pos()\r\n  {\r\n    return new Phaser.Point(this.m_vPosition.x, this.m_vPosition.y);\r\n  }\r\n\r\n  SetPos(new_pos)\r\n  {\r\n    this.m_vPosition = new Phaser.Point(new_pos.x, new_pos.y);\r\n  }\r\n\r\n  BRadius()\r\n  {\r\n    return this.m_dBoundingRadius;\r\n  }\r\n\r\n  SetBRadius(r)\r\n  {\r\n    this.m_dBoundingRadius = r;\r\n  }\r\n\r\n  IsTagged()\r\n  {\r\n    return this.m_bTag;\r\n  }\r\n\r\n  Tag()\r\n  {\r\n    this.m_bTag = true;\r\n  }\r\n\r\n  UnTag()\r\n  {\r\n    this.m_bTag = false;\r\n  }\r\n\r\n  Scale()\r\n  {\r\n    return this.m_vScale;\r\n  }\r\n\r\n  SetScale(val)\r\n  {\r\n    this.m_dBoundingRadius *= Math.max(val.x, val.y) / Math.max(m_vScale.x, m_vScale.y);\r\n    this.m_vScale = val;\r\n  }\r\n\r\n  SetScale(val)\r\n  {\r\n    this.m_dBoundingRadius *= (val / Math.max(m_vScale.x, m_vScale.y));\r\n    this.m_vScale = new Phaser.Point(val, val);\r\n  }\r\n\r\n  EntityType()\r\n  {\r\n    return this.m_iType;\r\n  }\r\n\r\n  SetEntityType(new_type)\r\n  {\r\n    this.m_iType = new_type;\r\n  }\r\n\r\n}\r\nmodule.exports.BaseGameEntity = BaseGameEntity;\r\n","'use strict';\r\n\r\nvar ColorTeam = {\r\n  RED: 1,\r\n  BLUE: 2,\r\n};\r\n\r\nmodule.exports.ColorTeam = ColorTeam;\r\n","'use strict';\r\n\r\nclass EntityManager\r\n{\r\n  constructor()\r\n  {\r\n    this.m_EntityMap = new Map();\r\n  }\r\n\r\n  GetEntityFromID(pEntityID)\r\n  {\r\n    if (this.m_EntityMap.has(pEntityID))\r\n    {\r\n      return this.m_EntityMap.get(pEntityID);\r\n    }\r\n  }\r\n\r\n  //--------------------------- RemoveEntity ------------------------------------\r\n  //-----------------------------------------------------------------------------\r\n  RemoveEntity(pEntity)\r\n  {\r\n    this.m_EntityMap.delete(pEntity.ID());\r\n  }\r\n\r\n  //---------------------------- RegisterEntity ---------------------------------\r\n  //-----------------------------------------------------------------------------\r\n  RegisterEntity(NewEntity)\r\n  {\r\n    this.m_EntityMap.set(NewEntity.ID(), NewEntity);\r\n  }\r\n\r\n  Reset() {this.m_EntityMap.clear();}\r\n\r\n}\r\n\r\nif (typeof GLOBAL_EntityManager === 'undefined') {\r\n  var GLOBAL_EntityManager = new EntityManager;\r\n}\r\n\r\nmodule.exports.EntityManager = EntityManager;\r\nmodule.exports.GLOBAL_EntityManager = GLOBAL_EntityManager;\r\n","'use strict';\r\n\r\nvar PlayerBaseExports = require('./PlayerBase');\r\nvar PlayerBase = PlayerBaseExports.PlayerBase;\r\n\r\nvar StateMachineExports = require('./StateMachine');\r\nvar StateMachine = StateMachineExports.StateMachine;\r\n\r\nvar ColorTeamExports = require('./ColorTeam');\r\nvar ColorTeam = ColorTeamExports.ColorTeam;\r\n\r\nvar RegulatorExports = require('./Regulator');\r\nvar Regulator = RegulatorExports.Regulator;\r\n\r\nvar FieldPlayerStatesExports = require('./FieldPlayerStates');\r\nvar FieldPlayerStates = FieldPlayerStatesExports.FieldPlayerStates;\r\n\r\nvar ChaseBall = FieldPlayerStatesExports.ChaseBall;\r\nvar SupportAttacker = FieldPlayerStatesExports.SupportAttacker;\r\nvar ReturnToHomeRegion = FieldPlayerStatesExports.ReturnToHomeRegion;\r\nvar Wait = FieldPlayerStatesExports.Wait;\r\nvar KickBall = FieldPlayerStatesExports.KickBall;\r\nvar Dribble = FieldPlayerStatesExports.Dribble;\r\nvar ReceiveBall = FieldPlayerStatesExports.ReceiveBall;\r\n\r\nvar TransformationsExports = require('./Transformations');\r\nvar Transformations = TransformationsExports.Transformations;\r\n\r\nvar Params = require('./Params');\r\n\r\nfunction listener()\r\n{\r\n  document.getElementById('player').style.display = 'block';\r\n}\r\n\r\nfunction clamp(val, min, max)\r\n{\r\n  return Math.max(min, Math.min(max, val));\r\n}\r\n\r\nclass FieldPlayer extends PlayerBase\r\n{\r\n  constructor(game, home_team, home_region, start_state, heading, velocity, mass, max_force, max_speed, max_turn_rate, scale, role)\r\n  {\r\n    super(game, home_team, home_region, heading, velocity, mass, max_force, max_speed, max_turn_rate, scale, role);\r\n\r\n    this.m_pStateMachine =  new StateMachine(this);\r\n\r\n    if (start_state)\r\n    {\r\n      this.m_pStateMachine.SetCurrentState(start_state);\r\n      this.m_pStateMachine.SetPreviousState(start_state);\r\n      this.m_pStateMachine.SetGlobalState(new FieldPlayerStates());\r\n      this.m_pStateMachine.CurrentState().Enter(this);\r\n    }\r\n\r\n    this.m_pSteering.SeparationOn();\r\n\r\n    //set up the kick regulator\r\n    this.m_pKickLimiter = new Regulator(Params.PlayerKickFrequency);\r\n  }\r\n\r\n  HandleMessage(msg)\r\n  {\r\n    return this.m_pStateMachine.HandleMessage(msg);\r\n  }\r\n\r\n  GetFSM()\r\n  {\r\n    return this.m_pStateMachine;\r\n  }\r\n\r\n  isReadyForNextKick()\r\n  {\r\n    return this.m_pKickLimiter.isReady();\r\n  }\r\n\r\n  RenderDetailsPlayer(sprite, pointer)\r\n  {\r\n  }\r\n\r\n  Render(game)\r\n  {\r\n    this.sprite = game.add.sprite(this.m_vPosition.x, this.m_vPosition.y, 'ball');\r\n    this.sprite.anchor.setTo(0.5, 0.5);\r\n    this.sprite.scale.setTo(0.2, 0.2);\r\n\r\n    if (this.m_pTeam.Color() == ColorTeam.RED)\r\n     this.sprite.tint = 0xB40404;\r\n    else\r\n     this.sprite.tint = 0x0404B4;\r\n\r\n    this.sprite.inputEnabled = true;\r\n    this.sprite.events.onInputDown.add(this.RenderDetailsPlayer, this);\r\n\r\n    this.sprite_heading = game.add.sprite(this.m_vPosition.x, this.m_vPosition.y, 'arrow');\r\n    this.sprite_heading.anchor.setTo(0.5, 0.5);\r\n    this.sprite_heading.scale.setTo(0.2, 0.2);\r\n\r\n    this.text1 = game.add.text(this.m_vPosition.x - 30, this.m_vPosition.y + 10, 'Ronaldo - ' + this.ID(), { font: '12px Verdana', fill: '#ffffff' });\r\n    this.text2 = game.add.text(this.m_vPosition.x - 30, this.m_vPosition.y + 20, this.m_pStateMachine.GetNameOfCurrentState(), { font: '12px Verdana', fill: '#ffffff' });\r\n  }\r\n\r\n  Update(game)\r\n  {\r\n    this.text1.destroy();\r\n    this.text2.destroy();\r\n\r\n    this.text1 = game.add.text(this.m_vPosition.x - 30, this.m_vPosition.y + 10, 'Ronaldo - ' + this.ID(), { font: '12px Verdana', fill: '#ffffff' });\r\n    this.text2 = game.add.text(this.m_vPosition.x - 30, this.m_vPosition.y + 20, this.m_pStateMachine.GetNameOfCurrentState(), { font: '12px Verdana', fill: '#ffffff' });\r\n\r\n    this.sprite.x = this.m_vPosition.x;\r\n    this.sprite.y = this.m_vPosition.y;\r\n\r\n    this.sprite_heading.x = this.m_vPosition.x;\r\n    this.sprite_heading.y = this.m_vPosition.y;\r\n\r\n    this.m_pStateMachine.Update();\r\n    this.m_pSteering.Calculate();\r\n\r\n    if (Transformations.isZero(this.m_pSteering.Force()))\r\n    {\r\n      var BrakingRate = 0.8;\r\n\r\n      this.m_vVelocity = new Phaser.Point(this.m_vVelocity.x * BrakingRate, this.m_vVelocity.y * BrakingRate);\r\n    }\r\n\r\n    var TurningForce = this.m_pSteering.SideComponent();\r\n\r\n    TurningForce = Transformations.Clamp(TurningForce, -Params.PlayerMaxTurnRate, Params.PlayerMaxTurnRate);\r\n\r\n    //rotate the heading vector\r\n    this.m_vHeading.rotate(0, 0, TurningForce);\r\n\r\n    this.sprite_heading.rotation += TurningForce;\r\n\r\n    //make sure the velocity vector points in the same direction as\r\n    //the heading vector\r\n    this.m_vVelocity = new Phaser.Point(this.m_vHeading.x * this.m_vVelocity.getMagnitude(), this.m_vHeading.y * this.m_vVelocity.getMagnitude());\r\n\r\n    //and recreate m_vSide\r\n    this.m_vSide = new Phaser.Point(this.m_vHeading.x, this.m_vHeading.y).perp();\r\n\r\n    //now to calculate the acceleration due to the force exerted by\r\n    //the forward component of the steering force in the direction\r\n    //of the player's heading\r\n\r\n    var tmpvalue = this.m_pSteering.ForwardComponent() / this.m_dMass;\r\n    var accel = new Phaser.Point(this.m_vHeading.x * tmpvalue, this.m_vHeading.y * tmpvalue);\r\n\r\n    this.m_vVelocity.add(accel.x, accel.y);\r\n\r\n    //make sure player does not exceed maximum velocity\r\n    //this.m_vVelocity.Truncate(m_dMaxSpeed);\r\n    //console.log(\"Calculate m_vVelocity\\n\");\r\n    Transformations.Truncate(this.m_vVelocity, this.m_dMaxSpeed);\r\n    /*\r\n    if (this.m_vVelocity.getMagnitude() > this.m_dMaxSpeed)\r\n    {\r\n     this.m_vVelocity.normalize();\r\n     this.m_vVelocity.x = this.m_vVelocity.x * this.m_dMaxSpeed;\r\n     this.m_vVelocity.y = this.m_vVelocity.y * this.m_dMaxSpeed;\r\n    }\r\n  */\r\n    //update the position\r\n    this.m_vPosition.add(this.m_vVelocity.x, this.m_vVelocity.y);\r\n\r\n    /*\r\n      //enforce a non-penetration constraint if desired\r\n      if(Params.bNonPenetrationConstraint)\r\n      {\r\n       //EnforceNonPenetrationContraint(this, AutoList<PlayerBase>::GetAllMembers());\r\n      }*/\r\n\r\n  }\r\n}\r\n\r\nmodule.exports.FieldPlayer = FieldPlayer;\r\n","'use strict';\r\n\r\nvar StateExports = require('./State');\r\nvar State = StateExports.State;\r\n\r\nvar MessageDispatcherExports = require('./MessageDispatcher');\r\nvar MessageDispatcher = MessageDispatcherExports.MessageDispatcher;\r\nvar SEND_MSG_IMMEDIATELY = MessageDispatcherExports.SEND_MSG_IMMEDIATELY;\r\nvar NO_ADDITIONAL_INFO = MessageDispatcherExports.NO_ADDITIONAL_INFO;\r\nvar SENDER_ID_IRRELEVANT = MessageDispatcherExports.SENDER_ID_IRRELEVANT;\r\nvar GLOBAL_MessageDispatcher = MessageDispatcherExports.GLOBAL_MessageDispatcher;\r\n\r\nvar SoccerMessagesExports = require('./SoccerMessages');\r\nvar SoccerMessages = SoccerMessagesExports.SoccerMessages;\r\nvar MessageType = SoccerMessagesExports.MessageType;\r\n\r\nvar RegionExports = require('./Region');\r\nvar region_modifier = RegionExports.region_modifier;\r\n\r\nvar SoccerBallExports = require('./SoccerBall');\r\nvar SoccerBall = SoccerBallExports.SoccerBall;\r\n\r\nvar TransformationsExports = require('./Transformations');\r\nvar Transformations = TransformationsExports.Transformations;\r\n\r\nvar Params = require('./Params');\r\n\r\nclass FieldPlayerStates extends State\r\n{\r\n  constructor()\r\n  {\r\n    super('FieldPlayerStates');\r\n  }\r\n\r\n  Enter(player)\r\n  {\r\n\r\n  }\r\n\r\n  Execute(player)\r\n  {\r\n    //if a player is in possession and close to the ball reduce his max speed\r\n    if ((player.BallWithinReceivingRange()) && (player.isControllingPlayer()))\r\n    {\r\n      player.SetMaxSpeed(Params.PlayerMaxSpeedWithBall);\r\n    } else\r\n    {\r\n      player.SetMaxSpeed(Params.PlayerMaxSpeedWithoutBall);\r\n    }\r\n  }\r\n\r\n  Exit(player)\r\n  {\r\n\r\n  }\r\n\r\n  OnMessage(player, telegram)\r\n  {\r\n    switch (telegram.Msg)\r\n    {\r\n    case MessageType.Msg_ReceiveBall:\r\n      {\r\n       //set the target\r\n       player.Steering().SetTarget(telegram.ExtraInfo);\r\n\r\n       //change state\r\n       player.GetFSM().ChangeState(new ReceiveBall());\r\n\r\n       return true;\r\n      }\r\n\r\n    case MessageType.Msg_SupportAttacker:\r\n      {\r\n       //if already supporting just return\r\n       if (player.GetFSM().isInState(new SupportAttacker()))\r\n       {\r\n        return true;\r\n       }\r\n         \r\n       //set the target to be the best supporting position\r\n       player.Steering().SetTarget(player.Team().GetSupportSpot());\r\n\r\n       //change the state\r\n       player.GetFSM().ChangeState(new SupportAttacker());\r\n\r\n       return true;\r\n      }\r\n\r\n    case MessageType.Msg_Wait:\r\n      {\r\n       //change the state\r\n       player.GetFSM().ChangeState(new Wait());\r\n\r\n       return true;\r\n      }\r\n\r\n    case MessageType.Msg_GoHome:\r\n      {\r\n       player.SetDefaultHomeRegion();\r\n        \r\n       player.GetFSM().ChangeState(new ReturnToHomeRegion());\r\n\r\n       return true;\r\n      }\r\n\r\n    case MessageType.Msg_PassToMe:\r\n      {  \r\n       //get the position of the player requesting the pass\r\n       //FieldPlayer* receiver = static_cast<FieldPlayer*>(telegram.ExtraInfo);\r\n       var receiver = telegram.ExtraInfo;\r\n\r\n       //if the ball is not within kicking range or their is already a\r\n       //receiving player, this player cannot pass the ball to the player\r\n       //making the request.\r\n       if (player.Team().Receiver() != null ||\r\n        !player.BallWithinKickingRange())\r\n       {\r\n        return true;\r\n       }\r\n        \r\n       //make the pass\r\n       player.Ball().Kick(new Phaser.Point(receiver.Pos().x - player.Ball().Pos().x, receiver.Pos().y - player.Ball().Pos().y),\r\n              Params.MaxPassingForce);\r\n       \r\n       //let the receiver know a pass is coming\r\n       GLOBAL_MessageDispatcher.DispatchMsg(SEND_MSG_IMMEDIATELY,\r\n              player.ID(),\r\n              receiver.ID(),\r\n              MessageType.Msg_ReceiveBall,\r\n              receiver.Pos());\r\n\r\n       //change state\r\n       player.GetFSM().ChangeState(new Wait());\r\n\r\n       player.FindSupport();\r\n\r\n       return true;\r\n      }\r\n\r\n  }//end switch\r\n\r\n    return false;\r\n  }\r\n\r\n  name()\r\n  {\r\n    return 'FieldPlayerStates';\r\n  }\r\n}\r\n\r\n//***************************************************************************** CHASEBALL\r\n\r\nclass ChaseBall extends State\r\n{\r\n  constructor()\r\n  {\r\n    super('ChaseBall');\r\n  }\r\n\r\n  Enter(player)\r\n  {\r\n    player.Steering().SeekOn();\r\n  }\r\n\r\n  Execute(player)\r\n  {\r\n    //if the ball is within kicking range the player changes state to KickBall.\r\n    if (player.BallWithinKickingRange())\r\n    {\r\n      player.GetFSM().ChangeState(new KickBall());\r\n\r\n      return;\r\n    }\r\n\r\n    //if the player is the closest player to the ball then he should keep\r\n    //chasing it\r\n    if (player.isClosestTeamMemberToBall())\r\n    {\r\n      player.Steering().SetTarget(player.Ball().Pos());\r\n\r\n      return;\r\n    }\r\n\r\n    //if the player is not closest to the ball anymore, he should return back\r\n    //to his home region and wait for another opportunity\r\n\r\n    player.GetFSM().ChangeState(new ReturnToHomeRegion());\r\n  }\r\n\r\n  Exit(player)\r\n  {\r\n    player.Steering().SeekOff();\r\n  }\r\n\r\n  OnMessage(player, telegram)\r\n  {\r\n    return false;\r\n  }\r\n\r\n  name()\r\n  {\r\n    return 'ChaseBall';\r\n  }\r\n}\r\n\r\n\r\n//*****************************************************************************SUPPORT ATTACKING PLAYER\r\n\r\nclass SupportAttacker extends State\r\n{\r\n  constructor()\r\n  {\r\n    super('SupportAttacker');\r\n  }\r\n\r\n  Enter(player)\r\n  {\r\n    player.Steering().ArriveOn();\r\n\r\n    player.Steering().SetTarget(player.Team().GetSupportSpot());\r\n  }\r\n\r\n  Execute(player)\r\n  {\r\n    //if his team loses control go back home\r\n    if (!player.Team().InControl())\r\n    {\r\n      player.GetFSM().ChangeState(new ReturnToHomeRegion());\r\n      return;\r\n    }\r\n\r\n\r\n    //if the best supporting spot changes, change the steering target\r\n    if (player.Team().GetSupportSpot() != player.Steering().Target())\r\n    {\r\n      player.Steering().SetTarget(player.Team().GetSupportSpot());\r\n\r\n      player.Steering().ArriveOn();\r\n    }\r\n\r\n    //if this player has a shot at the goal AND the attacker can pass\r\n    //the ball to him the attacker should pass the ball to this player\r\n    var ret_canshoot = player.Team().CanShoot(player.Pos(),\r\n                                 Params.MaxShootingForce);\r\n    if (ret_canshoot[0])\r\n    {\r\n      player.Team().RequestPass(player);\r\n    }\r\n\r\n    //if this player is located at the support spot and his team still have\r\n    //possession, he should remain still and turn to face the ball\r\n    if (player.AtTarget())\r\n    {\r\n      player.Steering().ArriveOff();\r\n\r\n      //the player should keep his eyes on the ball!\r\n      player.TrackBall();\r\n\r\n      player.SetVelocity(new Phaser.Point(0, 0));\r\n\r\n      //if not threatened by another player request a pass\r\n      if (!player.isThreatened())\r\n      {\r\n        player.Team().RequestPass(player);\r\n      }\r\n    }\r\n  }\r\n\r\n  Exit(player)\r\n  {\r\n    //set supporting player to null so that the team knows it has to\r\n    //determine a new one.\r\n    player.Team().SetSupportingPlayer(null);\r\n\r\n    player.Steering().ArriveOff();\r\n  }\r\n\r\n  OnMessage(player, telegram)\r\n  {\r\n    return false;\r\n  }\r\n\r\n  name()\r\n  {\r\n    return 'SupportAttacker';\r\n  }\r\n}\r\n\r\n\r\n\r\n//************************************************************************ RETURN TO HOME REGION\r\n\r\nclass ReturnToHomeRegion extends State\r\n{\r\n  constructor()\r\n  {\r\n    super('ReturnToHomeRegion');\r\n  }\r\n\r\n  Enter(player)\r\n  {\r\n    player.Steering().ArriveOn();\r\n\r\n    if (!player.HomeRegion().Inside(player.Steering().Target(), region_modifier.halfsize))\r\n    {\r\n      player.Steering().SetTarget(player.HomeRegion().Center());\r\n    }\r\n  }\r\n\r\n  Execute(player)\r\n  {\r\n    if (player.Pitch().GameOn())\r\n    {\r\n      //if the ball is nearer this player than any other team member  &&\r\n      //there is not an assigned receiver && the goalkeeper does not gave\r\n      //the ball, go chase it\r\n      if (player.isClosestTeamMemberToBall() &&\r\n        (player.Team().Receiver() == null) &&\r\n        !player.Pitch().GoalKeeperHasBall())\r\n      {\r\n        player.GetFSM().ChangeState(new ChaseBall());\r\n\r\n        return;\r\n      }\r\n    }\r\n\r\n    //if game is on and close enough to home, change state to wait and set the\r\n    //player target to his current position.(so that if he gets jostled out of\r\n    //position he can move back to it)\r\n    if (player.Pitch().GameOn() && player.HomeRegion().Inside(player.Pos(),\r\n                   region_modifier.halfsize))\r\n    {\r\n      player.Steering().SetTarget(player.Pos());\r\n      player.GetFSM().ChangeState(new Wait());\r\n    }\r\n    //if game is not on the player must return much closer to the center of his\r\n    //home region\r\n    else if (!player.Pitch().GameOn() && player.AtTarget())\r\n    {\r\n      player.GetFSM().ChangeState(new Wait());\r\n    }\r\n  }\r\n\r\n  Exit(player)\r\n  {\r\n    player.Steering().ArriveOff();\r\n  }\r\n\r\n  OnMessage(player, telegram)\r\n  {\r\n    return false;\r\n  }\r\n\r\n  name()\r\n  {\r\n    return 'ReturnToHomeRegion';\r\n  }\r\n}\r\n\r\n\r\n\r\n//***************************************************************************** WAIT\r\n\r\nclass Wait extends State\r\n{\r\n  constructor()\r\n  {\r\n    super('Wait');\r\n  }\r\n\r\n  Enter(player)\r\n  {\r\n    //if the game is not on make sure the target is the center of the player's\r\n    //home region. This is ensure all the players are in the correct positions\r\n    //ready for kick off\r\n    if (!player.Pitch().GameOn())\r\n    {\r\n      player.Steering().SetTarget(player.HomeRegion().Center());\r\n    }\r\n  }\r\n\r\n  Execute(player)\r\n  {\r\n    //if the player has been jostled out of position, get back in position\r\n    if (!player.AtTarget())\r\n    {\r\n      player.Steering().ArriveOn();\r\n      return;\r\n    } else\r\n    {\r\n      player.Steering().ArriveOff();\r\n\r\n      player.SetVelocity(new Phaser.Point(0, 0));\r\n\r\n      //the player should keep his eyes on the ball!\r\n      player.TrackBall();\r\n    }\r\n\r\n    //if this player's team is controlling AND this player is not the attacker\r\n    //AND is further up the field than the attacker he should request a pass.\r\n    if (player.Team().InControl()    &&\r\n     (!player.isControllingPlayer()) &&\r\n       player.isAheadOfAttacker())\r\n    {\r\n      player.Team().RequestPass(player);\r\n\r\n      return;\r\n    }\r\n\r\n    if (player.Pitch().GameOn())\r\n    {\r\n      //if the ball is nearer this player than any other team member  AND\r\n      //there is not an assigned receiver AND neither goalkeeper has\r\n      //the ball, go chase it\r\n      if (player.isClosestTeamMemberToBall() &&\r\n       player.Team().Receiver() == null  &&\r\n        !player.Pitch().GoalKeeperHasBall())\r\n      {\r\n        player.GetFSM().ChangeState(new ChaseBall());\r\n\r\n        return;\r\n      }\r\n    }\r\n  }\r\n\r\n  Exit(player) {}\r\n\r\n  OnMessage(player, telegram)\r\n  {\r\n    return false;\r\n  }\r\n\r\n  name()\r\n  {\r\n    return 'Wait';\r\n  }\r\n}\r\n\r\n\r\n\r\n\r\n//************************************************************************ KICK BALL\r\n\r\nclass KickBall extends State\r\n{\r\n  constructor()\r\n  {\r\n    super('KickBall');\r\n  }\r\n\r\n  Enter(player)\r\n  {\r\n    //let the team know this player is controlling\r\n    player.Team().SetControllingPlayer(player);\r\n\r\n    //the player can only make so many kick attempts per second.\r\n    if (!player.isReadyForNextKick())\r\n    {\r\n      player.GetFSM().ChangeState(new ChaseBall());\r\n    }\r\n  }\r\n\r\n  Execute(player)\r\n  {\r\n    //calculate the dot product of the vector pointing to the ball\r\n    //and the player's heading\r\n\r\n    var ToBall = new Phaser.Point(player.Ball().Pos().x - player.Pos().x,\r\n     player.Ball().Pos().y - player.Pos().y);\r\n    var dot    = player.Heading().dot(ToBall.normalize());\r\n\r\n    //cannot kick the ball if the goalkeeper is in possession or if it is\r\n    //behind the player or if there is already an assigned receiver. So just\r\n    //continue chasing the ball\r\n    if (player.Team().Receiver() != null   ||\r\n     player.Pitch().GoalKeeperHasBall() || (dot < 0))\r\n    {\r\n      player.GetFSM().ChangeState(new ChaseBall());\r\n\r\n      return;\r\n    }\r\n\r\n    // Attempt a shot at the goal\r\n\r\n    //the dot product is used to adjust the shooting force. The more\r\n    //directly the ball is ahead, the more forceful the kick\r\n    var power = Params.MaxShootingForce * dot;\r\n\r\n    //if it is determined that the player could score a goal from this position\r\n    //OR if he should just kick the ball anyway, the player will attempt\r\n    //to make the shot\r\n\r\n    var ret_canshoot = player.Team().CanShoot(player.Ball().Pos(), power);\r\n\r\n    if (ret_canshoot[0] ||\r\n     (Math.random() < Params.ChancePlayerAttemptsPotShot))\r\n    {\r\n      //if a shot is possible, this vector will hold the position along the\r\n      //opponent's goal line the player should aim for.\r\n      var BallTarget = ret_canshoot[1];\r\n      //add some noise to the kick. We don't want players who are\r\n      //too accurate! The amount of noise can be adjusted by altering\r\n      //Prm.PlayerKickingAccuracy\r\n      BallTarget = SoccerBall.AddNoiseToKick(player.Ball().Pos(), BallTarget);\r\n\r\n      //this is the direction the ball will be kicked in\r\n      var KickDirection = new Phaser.Point(BallTarget.x - player.Ball().Pos().x, BallTarget.y - player.Ball().Pos().y);\r\n\r\n      player.Ball().Kick(KickDirection, power);\r\n\r\n      //change state\r\n      player.GetFSM().ChangeState(new Wait());\r\n\r\n      player.FindSupport();\r\n\r\n      return;\r\n    }\r\n\r\n    /* Attempt a pass to a player */\r\n\r\n    //if a receiver is found this will point to it\r\n\r\n    var receiver = null;\r\n\r\n    power = Params.MaxPassingForce * dot;\r\n\r\n    var ret_findpass = player.Team().FindPass(player, power, Params.MinPassDist);\r\n\r\n    //test if there are any potential candidates available to receive a pass\r\n    if (player.isThreatened() && ret_findpass[0])\r\n    {\r\n      var receiver = ret_findpass[1];\r\n      var BallTarget = ret_findpass[2];\r\n\r\n      //add some noise to the kick\r\n      BallTarget = SoccerBall.AddNoiseToKick(player.Ball().Pos(), BallTarget);\r\n\r\n      var KickDirection = new Phaser.Point(BallTarget.x - player.Ball().Pos().x, BallTarget.y - player.Ball().Pos().y);\r\n\r\n      player.Ball().Kick(KickDirection, power);\r\n\r\n      //let the receiver know a pass is coming\r\n      GLOBAL_MessageDispatcher.DispatchMsg(SEND_MSG_IMMEDIATELY,\r\n                               player.ID(),\r\n                               receiver.ID(),\r\n                               MessageType.Msg_ReceiveBall,\r\n                               BallTarget);\r\n\r\n\r\n      //the player should wait at his current position unless instruced\r\n      //otherwise\r\n      player.GetFSM().ChangeState(new Wait());\r\n\r\n      player.FindSupport();\r\n\r\n      return;\r\n    }\r\n\r\n    //cannot shoot or pass, so dribble the ball upfield\r\n    else\r\n    {\r\n      player.FindSupport();\r\n\r\n      player.GetFSM().ChangeState(new Dribble());\r\n    }\r\n  }\r\n\r\n  Exit(player)\r\n  {\r\n  }\r\n\r\n  OnMessage(player, telegram)\r\n  {\r\n    return false;\r\n  }\r\n\r\n  name()\r\n  {\r\n    return 'KickBall';\r\n  }\r\n}\r\n\r\nclass Dribble extends State\r\n{\r\n  constructor()\r\n  {\r\n    super('Dribble');\r\n  }\r\n\r\n  Enter(player)\r\n  {\r\n    //let the team know this player is controlling\r\n    player.Team().SetControllingPlayer(player);\r\n  }\r\n\r\n  Execute(player)\r\n  {\r\n    var dot = player.Team().HomeGoal().Facing().dot(player.Heading());\r\n\r\n    //if the ball is between the player and the home goal, it needs to swivel\r\n    // the ball around by doing multiple small kicks and turns until the player\r\n    //is facing in the correct direction\r\n    if (dot < 0)\r\n    {\r\n      //the player's heading is going to be rotated by a small amount (Pi/4)\r\n      //and then the ball will be kicked in that direction\r\n      var direction = player.Heading();\r\n\r\n      //calculate the sign (+/-) of the angle between the player heading and the\r\n      //facing direction of the goal so that the player rotates around in the\r\n      //correct direction\r\n      var angle = (Math.PI / 4) * -1 * Transformations.PointsSign(player.Team().HomeGoal().Facing(), player.Heading());\r\n\r\n      direction.rotate(direction.x, direction.y, angle);\r\n\r\n      //this value works well whjen the player is attempting to control the\r\n      //ball and turn at the same time\r\n      var KickingForce = 0.8;\r\n\r\n      player.Ball().Kick(direction, KickingForce);\r\n    }\r\n\r\n    //kick the ball down the field\r\n    else\r\n    {\r\n      player.Ball().Kick(player.Team().HomeGoal().Facing(),\r\n                            Params.MaxDribbleForce);\r\n    }\r\n\r\n    //the player has kicked the ball so he must now change state to follow it\r\n    player.GetFSM().ChangeState(new ChaseBall());\r\n\r\n    return;\r\n  }\r\n\r\n  Exit(player)\r\n  {\r\n  }\r\n\r\n  OnMessage(player, telegram)\r\n  {\r\n    return false;\r\n  }\r\n\r\n  name()\r\n  {\r\n    return 'Dribble';\r\n  }\r\n}\r\n\r\nclass ReceiveBall extends State\r\n{\r\n  constructor()\r\n  {\r\n    super('ReceiveBall');\r\n  }\r\n\r\n  Enter(player)\r\n  {\r\n    //let the team know this player is receiving the ball\r\n    player.Team().SetReceiver(player);\r\n\r\n    //this player is also now the controlling player\r\n    player.Team().SetControllingPlayer(player);\r\n\r\n    //there are two types of receive behavior. One uses arrive to direct\r\n    //the receiver to the position sent by the passer in its telegram. The\r\n    //other uses the pursuit behavior to pursue the ball.\r\n    //This statement selects between them dependent on the probability\r\n    //ChanceOfUsingArriveTypeReceiveBehavior, whether or not an opposing\r\n    //player is close to the receiving player, and whether or not the receiving\r\n    //player is in the opponents 'hot region' (the third of the pitch closest\r\n    //to the opponent's goal\r\n    var PassThreatRadius = 70.0;\r\n\r\n    if ((player.InHotRegion() ||\r\n     Math.random() < Params.ChanceOfUsingArriveTypeReceiveBehavior) &&\r\n      !player.Team().isOpponentWithinRadius(player.Pos(), PassThreatRadius))\r\n    {\r\n      player.Steering().ArriveOn();\r\n    } else\r\n    {\r\n      player.Steering().PursuitOn();\r\n    }\r\n  }\r\n\r\n  Execute(player)\r\n  {\r\n    //if the ball comes close enough to the player or if his team lose control\r\n    //he should change state to chase the ball\r\n    if (player.BallWithinReceivingRange() || !player.Team().InControl())\r\n    {\r\n      player.GetFSM().ChangeState(new ChaseBall());\r\n\r\n      return;\r\n    }\r\n\r\n    if (player.Steering().PursuitIsOn())\r\n    {\r\n      player.Steering().SetTarget(player.Ball().Pos());\r\n    }\r\n\r\n    //if the player has 'arrived' at the steering target he should wait and\r\n    //turn to face the ball\r\n    if (player.AtTarget())\r\n    {\r\n      player.Steering().ArriveOff();\r\n      player.Steering().PursuitOff();\r\n      player.TrackBall();\r\n      player.SetVelocity(new Phaser.Point(0, 0));\r\n    }\r\n  }\r\n\r\n  Exit(player)\r\n  {\r\n    player.Steering().ArriveOff();\r\n    player.Steering().PursuitOff();\r\n\r\n    player.Team().SetReceiver(null);\r\n  }\r\n\r\n  OnMessage(player, telegram)\r\n  {\r\n    return false;\r\n  }\r\n\r\n  name()\r\n  {\r\n    return 'ReceiveBall';\r\n  }\r\n}\r\n\r\nmodule.exports.FieldPlayerStates = FieldPlayerStates;\r\nmodule.exports.ChaseBall = ChaseBall;\r\nmodule.exports.SupportAttacker = SupportAttacker;\r\nmodule.exports.ReturnToHomeRegion = ReturnToHomeRegion;\r\nmodule.exports.Wait = Wait;\r\nmodule.exports.KickBall = KickBall;\r\nmodule.exports.Dribble = Dribble;\r\nmodule.exports.ReceiveBall = ReceiveBall;\r\n","'use strict';\r\n\r\nclass Goal\r\n{\r\n  // left, right, facing\r\n  // Facing a vector representing the facing direction of the goal\r\n  constructor(left, right, facing)\r\n  {\r\n    this.m_vLeftPost = left;\r\n    this.m_vRightPost = right;\r\n    this.m_vFacing = facing;\r\n    this.m_vCenter = new Phaser.Point((left.x + right.x) / 2.0, (left.y + right.y) / 2.0);\r\n    this.m_iNumGoalsScored = 0;\r\n  }\r\n\r\n  Center()\r\n  {\r\n    return new Phaser.Point(this.m_vCenter.x, this.m_vCenter.y);\r\n  }\r\n\r\n  Facing()\r\n  {\r\n    return new Phaser.Point(this.m_vFacing.x, this.m_vFacing.y);\r\n  }\r\n\r\n  LeftPost()\r\n  {\r\n    return new Phaser.Point(this.m_vLeftPost.x, this.m_vLeftPost.y);\r\n  }\r\n\r\n  RightPost()\r\n  {\r\n    return new Phaser.Point(this.m_vRightPost.x, this.m_vRightPost.y);\r\n  }\r\n\r\n  NumGoalsScored()\r\n  {\r\n    return this.m_iNumGoalsScored;\r\n  }\r\n\r\n  ResetGoalsScored()\r\n  {\r\n    this.m_iNumGoalsScored = 0;\r\n  }\r\n\r\n  Scored(ball)\r\n  {\r\n    if (Phaser.Line.intersectsPoints(ball.Pos(), ball.OldPos(), this.m_vLeftPost, this.m_vRightPost) != null)\r\n    {\r\n      this.m_iNumGoalsScored++;\r\n\r\n      return true;\r\n    }\r\n\r\n    return false;\r\n  }\r\n}\r\n\r\nmodule.exports.Goal = Goal;\r\n","'use strict';\r\n\r\nvar PlayerBaseExports = require('./PlayerBase');\r\nvar PlayerBase = PlayerBaseExports.PlayerBase;\r\n\r\nvar ColorTeamExports = require('./ColorTeam');\r\nvar ColorTeam = ColorTeamExports.ColorTeam;\r\n\r\nvar StateMachineExports = require('./StateMachine');\r\nvar StateMachine = StateMachineExports.StateMachine;\r\n\r\nvar RegulatorExports = require('./Regulator');\r\nvar Regulator = RegulatorExports.Regulator;\r\n\r\nvar GoalkeeperStatesExports = require('./GoalkeeperStates');\r\nvar GoalkeeperStates = GoalkeeperStatesExports.GoalkeeperStates;\r\nvar TendGoal = GoalkeeperStatesExports.TendGoal;\r\nvar ReturnHome = GoalkeeperStatesExports.ReturnHome;\r\nvar InterceptBall = GoalkeeperStatesExports.InterceptBall;\r\nvar PutBallBackInPlay = GoalkeeperStatesExports.PutBallBackInPlay;\r\n\r\nvar Params = require('./Params');\r\n\r\nclass Goalkeeper extends PlayerBase\r\n{\r\n  constructor(game, home_team, home_region, start_state, heading, velocity, mass, max_force, max_speed, max_turn_rate, scale, role)\r\n  {\r\n    super(game, home_team, home_region, heading, velocity, mass, max_force, max_speed, max_turn_rate, scale, role);\r\n\r\n    this.m_pStateMachine =  new StateMachine(this);\r\n\r\n    //if (start_state)\r\n    //{\r\n    this.m_pStateMachine.SetCurrentState(start_state);\r\n    this.m_pStateMachine.SetPreviousState(start_state);\r\n    this.m_pStateMachine.SetGlobalState(new GoalkeeperStates());\r\n    this.m_pStateMachine.CurrentState().Enter(this);\r\n    //}\r\n  }\r\n\r\n  LookAt()\r\n  {\r\n    return new Phaser.Point(this.m_vLookAt.x, this.m_vLookAt.y);\r\n  }\r\n\r\n  SetLookAt(v)\r\n  {\r\n    this.m_vLookAt = new Phaser.Point(v.x, v.y);\r\n  }\r\n\r\n  HandleMessage(msg)\r\n  {\r\n    return this.m_pStateMachine.HandleMessage(msg);\r\n  }\r\n\r\n  Update(game)\r\n  {\r\n    this.text1.destroy();\r\n    this.text2.destroy();\r\n\r\n    this.text1 = game.add.text(this.m_vPosition.x - 30, this.m_vPosition.y + 10, 'Neuer', { font: '12px Verdana', fill: '#ffffff' });\r\n    this.text2 = game.add.text(this.m_vPosition.x - 30, this.m_vPosition.y + 20, this.m_pStateMachine.GetNameOfCurrentState(), { font: '12px Verdana', fill: '#ffffff' });\r\n\r\n    this.sprite.x = this.m_vPosition.x;\r\n    this.sprite.y = this.m_vPosition.y;\r\n\r\n    this.sprite_heading.x = this.m_vPosition.x;\r\n    this.sprite_heading.y = this.m_vPosition.y;\r\n\r\n    //run the logic for the current state\r\n    this.m_pStateMachine.Update();\r\n\r\n    //calculate the combined force from each steering behavior\r\n    var SteeringForce = this.m_pSteering.Calculate();\r\n\r\n    //Acceleration = Force/Mass\r\n    var Accelerationx = SteeringForce.x / this.m_dMass;\r\n    var Accelerationy = SteeringForce.y / this.m_dMass;\r\n\r\n    //update velocity\r\n    this.m_vVelocity.add(Accelerationx, Accelerationy);\r\n\r\n    //make sure player does not exceed maximum velocity\r\n    //this.m_vVelocity.Truncate(m_dMaxSpeed);\r\n\r\n    if (this.m_vVelocity.getMagnitude() > this.m_dMaxSpeed)\r\n   {\r\n      this.m_vVelocity.normalize();\r\n      this.m_vVelocity.x = this.m_vVelocity.x * this.m_dMaxSpeed;\r\n      this.m_vVelocity.y = this.m_vVelocity.y * this.m_dMaxSpeed;\r\n    }\r\n\r\n    //update the position\r\n    this.m_vPosition.add(this.m_vVelocity.x, this.m_vVelocity.y);\r\n\r\n\r\n    //enforce a non-penetration constraint if desired\r\n    if (Params.bNonPenetrationConstraint)\r\n    {\r\n      //EnforceNonPenetrationContraint(this, AutoList<PlayerBase>::GetAllMembers());\r\n    }\r\n\r\n    //update the heading if the player has a non zero velocity\r\n    if (!this.m_vVelocity.isZero())\r\n    {\r\n      this.m_vHeading = new Phaser.Point(this.m_vVelocity.x, this.m_vVelocity.y).normalize();\r\n\r\n      this.m_vSide = new Phaser.Point(this.m_vHeading.x, this.m_vHeading.y).perp();\r\n    }\r\n\r\n    //look-at vector always points toward the ball\r\n    if (!this.Pitch().GoalKeeperHasBall())\r\n    {\r\n      var tempvec = new Phaser.Point(this.Ball().Pos().x - this.Pos().x, this.Ball().Pos().y - this.Pos().y);\r\n      this.m_vLookAt = tempvec.normalize();\r\n    }\r\n  }\r\n\r\n  BallWithinRangeForIntercept()\r\n  {\r\n    return (this.game.math.distanceSq(this.Team().HomeGoal().Center().x, this.Team().HomeGoal().Center().y, this.Ball().Pos().x, this.Ball().Pos().y) <= Params.GoalKeeperInterceptRangeSq);\r\n  }\r\n\r\n  TooFarFromGoalMouth()\r\n  {\r\n    return (this.game.math.distanceSq(this.Pos().x, this.Pos().y, this.GetRearInterposeTarget().x, this.GetRearInterposeTarget().y) > Params.GoalKeeperInterceptRangeSq);\r\n  }\r\n\r\n  GetRearInterposeTarget()\r\n  {\r\n    var xPosTarget = this.Team().HomeGoal().Center().x;\r\n    var yPosTarget = this.Pitch().PlayingArea().Center().y -\r\n                       Params.GoalWidth * 0.5 + (this.Ball().Pos().y * Params.GoalWidth) /\r\n                       this.Pitch().PlayingArea().Height();\r\n\r\n    return new Phaser.Point(xPosTarget, yPosTarget);\r\n  }\r\n\r\n  GetFSM()\r\n  {\r\n    return this.m_pStateMachine;\r\n  }\r\n\r\n  Render(game)\r\n  {\r\n    this.sprite = game.add.sprite(this.m_vPosition.x, this.m_vPosition.y, 'ball');\r\n    this.sprite.anchor.setTo(0.5, 0.5);\r\n    this.sprite.scale.setTo(0.2, 0.2);\r\n\r\n    if (this.m_pTeam.Color() == ColorTeam.RED)\r\n     this.sprite.tint = 0xB40404;\r\n    else\r\n     this.sprite.tint = 0x0404B4;\r\n\r\n    this.sprite_heading = game.add.sprite(this.m_vPosition.x, this.m_vPosition.y, 'arrow');\r\n    this.sprite_heading.anchor.setTo(0.5, 0.5);\r\n    this.sprite_heading.scale.setTo(0.2, 0.2);\r\n\r\n    this.text1 = game.add.text(this.m_vPosition.x - 30, this.m_vPosition.y + 10, 'neur', { font: '12px Verdana', fill: '#ffffff' });\r\n    this.text2 = game.add.text(this.m_vPosition.x - 30, this.m_vPosition.y + 20, this.m_pStateMachine.GetNameOfCurrentState(), { font: '12px Verdana', fill: '#ffffff' });\r\n  }\r\n}\r\n\r\nmodule.exports.Goalkeeper = Goalkeeper;\r\n","'use strict';\r\n\r\nvar StateExports = require('./State');\r\nvar State = StateExports.State;\r\n\r\nvar MessageDispatcherExports = require('./MessageDispatcher');\r\nvar MessageDispatcher = MessageDispatcherExports.MessageDispatcher;\r\nvar SEND_MSG_IMMEDIATELY = MessageDispatcherExports.SEND_MSG_IMMEDIATELY;\r\nvar NO_ADDITIONAL_INFO = MessageDispatcherExports.NO_ADDITIONAL_INFO;\r\nvar SENDER_ID_IRRELEVANT = MessageDispatcherExports.SENDER_ID_IRRELEVANT;\r\nvar GLOBAL_MessageDispatcher = MessageDispatcherExports.GLOBAL_MessageDispatcher;\r\n\r\nvar SoccerMessagesExports = require('./SoccerMessages');\r\nvar SoccerMessages = SoccerMessagesExports.SoccerMessages;\r\nvar MessageType = SoccerMessagesExports.MessageType;\r\n\r\nvar Params = require('./Params');\r\n\r\nclass GoalkeeperStates extends State\r\n{\r\n  constructor()\r\n  {\r\n    super('GoalkeeperStates');\r\n  }\r\n\r\n  Enter(keeper)\r\n  {\r\n\r\n  }\r\n\r\n  Execute(keeper)\r\n  {\r\n\r\n  }\r\n\r\n  Exit(keeper)\r\n  {\r\n\r\n  }\r\n\r\n  OnMessage(keeper, telegram)\r\n  {\r\n    switch (telegram.Msg)\r\n    {\r\n    case MessageType.Msg_GoHome:\r\n      {\r\n        keeper.SetDefaultHomeRegion();\r\n        \r\n        keeper.GetFSM().ChangeState(new ReturnHome());\r\n      }\r\n\r\n    break;\r\n\r\n    case MessageType.Msg_ReceiveBall:\r\n      {\r\n        keeper.GetFSM().ChangeState(new InterceptBall());\r\n      }\r\n\r\n    break;\r\n\r\n  }//end switch\r\n\r\n    return false;\r\n  }\r\n\r\n  name()\r\n  {\r\n    return 'GoalkeeperStates';\r\n  }\r\n}\r\n\r\n//--------------------------- TendGoal -----------------------------------\r\n//\r\n//  This is the main state for the goalkeeper. When in this state he will\r\n//  move left to right across the goalmouth using the 'interpose' steering\r\n//  behavior to put himself between the ball and the back of the net.\r\n//\r\n//  If the ball comes within the 'goalkeeper range' he moves out of the\r\n//  goalmouth to attempt to intercept it. (see next state)\r\n//------------------------------------------------------------------------\r\n\r\nclass TendGoal extends State\r\n{\r\n  constructor()\r\n  {\r\n    super('TendGoal');\r\n  }\r\n\r\n  Enter(keeper)\r\n  {\r\n    //turn interpose on\r\n    keeper.Steering().InterposeOn(Params.GoalKeeperTendingDistance);\r\n\r\n    //interpose will position the agent between the ball position and a target\r\n    //position situated along the goal mouth. This call sets the target\r\n    keeper.Steering().SetTarget(keeper.GetRearInterposeTarget());\r\n  }\r\n\r\n  Execute(keeper)\r\n  {\r\n    //the rear interpose target will change as the ball's position changes\r\n    //so it must be updated each update-step\r\n    keeper.Steering().SetTarget(keeper.GetRearInterposeTarget());\r\n\r\n    //if the ball comes in range the keeper traps it and then changes state\r\n    //to put the ball back in play\r\n    if (keeper.BallWithinKeeperRange())\r\n    {\r\n      keeper.Ball().Trap();\r\n\r\n      keeper.Pitch().SetGoalKeeperHasBall(true);\r\n\r\n      keeper.GetFSM().ChangeState(new PutBallBackInPlay());\r\n\r\n      return;\r\n    }\r\n\r\n    //if ball is within a predefined distance, the keeper moves out from\r\n    //position to try and intercept it.\r\n    if (keeper.BallWithinRangeForIntercept() && !keeper.Team().InControl())\r\n    {\r\n      keeper.GetFSM().ChangeState(new InterceptBall());\r\n    }\r\n\r\n    //if the keeper has ventured too far away from the goal-line and there\r\n    //is no threat from the opponents he should move back towards it\r\n    if (keeper.TooFarFromGoalMouth() && keeper.Team().InControl())\r\n    {\r\n      keeper.GetFSM().ChangeState(new ReturnHome());\r\n\r\n      return;\r\n    }\r\n  }\r\n\r\n  Exit(keeper)\r\n  {\r\n    keeper.Steering().InterposeOff();\r\n  }\r\n\r\n  OnMessage(keeper, telegram)\r\n  {\r\n  }\r\n\r\n  name()\r\n  {\r\n    return 'TendGoal';\r\n  }\r\n}\r\n\r\n//------------------------- ReturnHome: ----------------------------------\r\n//\r\n//  In this state the goalkeeper simply returns back to the center of\r\n//  the goal region before changing state back to TendGoal\r\n//------------------------------------------------------------------------\r\n\r\nclass ReturnHome extends State\r\n{\r\n  constructor()\r\n  {\r\n    super('ReturnHome');\r\n  }\r\n\r\n  Enter(keeper)\r\n  {\r\n    keeper.Steering().ArriveOn();\r\n  }\r\n\r\n  Execute(keeper)\r\n  {\r\n    keeper.Steering().SetTarget(keeper.HomeRegion().Center());\r\n\r\n    //if close enough to home or the opponents get control over the ball,\r\n    //change state to tend goal\r\n    if (keeper.InHomeRegion() || !keeper.Team().InControl())\r\n    {\r\n      keeper.GetFSM().ChangeState(new TendGoal());\r\n    }\r\n  }\r\n\r\n  Exit(keeper)\r\n  {\r\n    keeper.Steering().ArriveOff();\r\n  }\r\n\r\n  OnMessage(keeper, telegram)\r\n  {\r\n  }\r\n\r\n  name()\r\n  {\r\n    return 'ReturnHome';\r\n  }\r\n}\r\n\r\n\r\n//----------------- InterceptBall ----------------------------------------\r\n//\r\n//  In this state the GP will attempt to intercept the ball using the\r\n//  pursuit steering behavior, but he only does so so long as he remains\r\n//  within his home region.\r\n//------------------------------------------------------------------------\r\nclass InterceptBall extends State\r\n{\r\n  constructor()\r\n  {\r\n    super('InterceptBall');\r\n  }\r\n\r\n  Enter(keeper)\r\n  {\r\n    keeper.Steering().PursuitOn();\r\n  }\r\n\r\n  Execute(keeper)\r\n  {\r\n    //if the goalkeeper moves to far away from the goal he should return to his\r\n    //home region UNLESS he is the closest player to the ball, in which case,\r\n    //he should keep trying to intercept it.\r\n    if (keeper.TooFarFromGoalMouth() && !keeper.isClosestPlayerOnPitchToBall())\r\n    {\r\n      keeper.GetFSM().ChangeState(new ReturnHome());\r\n\r\n      return;\r\n    }\r\n\r\n    //if the ball becomes in range of the goalkeeper's hands he traps the\r\n    //ball and puts it back in play\r\n    if (keeper.BallWithinKeeperRange())\r\n    {\r\n      keeper.Ball().Trap();\r\n\r\n      keeper.Pitch().SetGoalKeeperHasBall(true);\r\n\r\n      keeper.GetFSM().ChangeState(new PutBallBackInPlay());\r\n\r\n      return;\r\n    }\r\n  }\r\n\r\n  Exit(keeper)\r\n  {\r\n    keeper.Steering().PursuitOff();\r\n  }\r\n\r\n  OnMessage(keeper, telegram)\r\n  {\r\n  }\r\n\r\n  name()\r\n  {\r\n    return 'InterceptBall';\r\n  }\r\n}\r\n\r\n\r\n//--------------------------- PutBallBackInPlay --------------------------\r\n//\r\n//------------------------------------------------------------------------\r\nclass PutBallBackInPlay extends State\r\n{\r\n  constructor()\r\n  {\r\n    super('PutBallBackInPlay');\r\n  }\r\n\r\n  Enter(keeper)\r\n  {\r\n    //let the team know that the keeper is in control\r\n    keeper.Team().SetControllingPlayer(keeper);\r\n\r\n    //send all the players home\r\n    keeper.Team().Opponents().ReturnAllFieldPlayersToHome();\r\n    keeper.Team().ReturnAllFieldPlayersToHome();\r\n  }\r\n\r\n  Execute(keeper)\r\n  {\r\n    //test if there are players further forward on the field we might\r\n    //be able to pass to. If so, make a pass.\r\n    var ret = keeper.Team().FindPass(keeper,\r\n                                Params.MaxPassingForce,\r\n                                Params.GoalkeeperMinPassDist);\r\n\r\n    if (ret[0])\r\n    {\r\n      var receiver = ret[1];\r\n      var BallTarget = ret[2];\r\n\r\n      //make the pass\r\n      keeper.Ball().Kick(new Phaser.Point(BallTarget.x - keeper.Ball().Pos().x, BallTarget.y - keeper.Ball().Pos().y).normalize(), Params.MaxPassingForce);\r\n\r\n      //goalkeeper no longer has ball\r\n      keeper.Pitch().SetGoalKeeperHasBall(false);\r\n\r\n      //let the receiving player know the ball's comin' at him\r\n      GLOBAL_MessageDispatcher.DispatchMsg(SEND_MSG_IMMEDIATELY,\r\n                             keeper.ID(),\r\n                             receiver.ID(),\r\n                             MessageType.Msg_ReceiveBall,\r\n                             BallTarget);\r\n\r\n      //go back to tending the goal\r\n      keeper.GetFSM().ChangeState(new TendGoal());\r\n\r\n      return;\r\n    }\r\n\r\n    keeper.SetVelocity(new Phaser.Point(0, 0));\r\n  }\r\n\r\n  Exit(keeper)\r\n  {\r\n  }\r\n\r\n  OnMessage(keeper, telegram)\r\n  {\r\n  }\r\n\r\n  name()\r\n  {\r\n    return 'PutBallBackInPlay';\r\n  }\r\n}\r\n\r\nmodule.exports.GoalkeeperStates = GoalkeeperStates;\r\nmodule.exports.TendGoal = TendGoal;\r\nmodule.exports.ReturnHome = ReturnHome;\r\nmodule.exports.InterceptBall = InterceptBall;\r\nmodule.exports.PutBallBackInPlay = PutBallBackInPlay;\r\n","'use strict';\r\n\r\nvar EntityManagerExports = require('./EntityManager');\r\nvar EntityManager = EntityManagerExports.EntityManager;\r\nvar GLOBAL_EntityManager = EntityManagerExports.GLOBAL_EntityManager;\r\n\r\nvar TelegramExports = require('./Telegram');\r\nvar Telegram = TelegramExports.Telegram;\r\n\r\nvar SEND_MSG_IMMEDIATELY = 0.0;\r\nvar NO_ADDITIONAL_INFO   = 0;\r\nvar SENDER_ID_IRRELEVANT = -1;\r\n\r\nclass MessageDispatcher\r\n{\r\n  constructor()\r\n  {\r\n    this.PriorityQ = null;\r\n  }\r\n\r\n  Discharge(pReceiver, telegram)\r\n  {\r\n    if (!pReceiver.HandleMessage(telegram))\r\n    {\r\n\r\n    }\r\n  }\r\n\r\n  DispatchMsg(delay, sender, receiver, msg, AdditionalInfo = null)\r\n  {\r\n\r\n    //get a pointer to the receiver\r\n    var pReceiver = GLOBAL_EntityManager.GetEntityFromID(receiver);\r\n\r\n    //make sure the receiver is valid\r\n    if (pReceiver == null)\r\n    {\r\n      return;\r\n    }\r\n\r\n    //create the telegram\r\n    var telegram = new Telegram(0, sender, receiver, msg, AdditionalInfo);\r\n\r\n    //if there is no delay, route telegram immediately\r\n    if (delay <= 0.0)\r\n    {\r\n      //send the telegram to the recipient\r\n      this.Discharge(pReceiver, telegram);\r\n    }\r\n\r\n    //else calculate the time when the telegram should be dispatched\r\n    else\r\n    {\r\n      var CurrentTime = TickCounter.GetCurrentFrame();\r\n\r\n      telegram.DispatchTime = CurrentTime + delay;\r\n\r\n      this.PriorityQ.push(telegram);\r\n    }\r\n  }\r\n\r\n  //---------------------- DispatchDelayedMessages -------------------------\r\n  //\r\n  //  This function dispatches any telegrams with a timestamp that has\r\n  //  expired. Any dispatched telegrams are removed from the queue\r\n  //------------------------------------------------------------------------\r\n  DispatchDelayedMessages()\r\n  {\r\n    //first get current time\r\n    var CurrentTime = TickCounter.GetCurrentFrame();\r\n\r\n    //now peek at the queue to see if any telegrams need dispatching.\r\n    //remove all telegrams from the front of the queue that have gone\r\n    //past their sell by date\r\n    while (this.PriorityQ.length != 0 &&\r\n        (this.PriorityQ[0].DispatchTime < CurrentTime) &&\r\n           (this.PriorityQ[0].DispatchTime > 0))\r\n    {\r\n      //read the telegram from the front of the queue\r\n      var telegram = PriorityQ[0];\r\n\r\n      //find the recipient\r\n      var pReceiver = GLOBAL_EntityManager.GetEntityFromID(telegram.Receiver);\r\n\r\n      //send the telegram to the recipient\r\n      this.Discharge(pReceiver, telegram);\r\n\r\n      //remove it from the queue\r\n      this.PriorityQ.pop();\r\n    }\r\n  }\r\n}\r\n\r\nif (typeof GLOBAL_MessageDispatcher === 'undefined')\r\n    var GLOBAL_MessageDispatcher = new MessageDispatcher;\r\n\r\nmodule.exports.MessageDispatcher = MessageDispatcher;\r\nmodule.exports.SEND_MSG_IMMEDIATELY = SEND_MSG_IMMEDIATELY;\r\nmodule.exports.NO_ADDITIONAL_INFO = NO_ADDITIONAL_INFO;\r\nmodule.exports.SENDER_ID_IRRELEVANT = SENDER_ID_IRRELEVANT;\r\nmodule.exports.GLOBAL_MessageDispatcher = GLOBAL_MessageDispatcher;\r\n","'use strict';\r\n\r\nvar BaseGameEntityExports = require('./BaseGameEntity');\r\nvar BaseGameEntity = BaseGameEntityExports.BaseGameEntity;\r\n\r\nvar TransformationsExports = require('./Transformations');\r\nvar Transformations = TransformationsExports.Transformations;\r\n\r\nclass MovingEntity extends BaseGameEntity\r\n{\r\n  constructor(game, position, radius, velocity, max_speed, heading, mass, scale, turn_rate, max_force)\r\n  {\r\n    super(BaseGameEntity.GetNextValidID(), game);\r\n\r\n    this.m_vPosition = position;\r\n    this.m_dBoundingRadius = radius;\r\n    this.m_vScale = scale;\r\n\r\n    // direction\r\n    this.m_vheading_angle = 0;\r\n    this.m_vHeading = heading; //2dvector\r\n    this.m_vVelocity = velocity; //2dvector\r\n    this.m_vSide = new Phaser.Point(this.m_vHeading.x, this.m_vHeading.y).perp(); //2dvector\r\n    this.m_dMass = mass;\r\n    this.m_dMaxSpeed = max_speed;\r\n    this.m_dMaxForce = max_force;\r\n    this.m_dMaxTurnRate = turn_rate;\r\n  }\r\n\r\n  Velocity()\r\n  {\r\n    return new Phaser.Point(this.m_vVelocity.x, this.m_vVelocity.y);\r\n  }\r\n\r\n  SetVelocity(NewVel)\r\n  {\r\n    this.m_vVelocity = new Phaser.Point(NewVel.x, NewVel.y);\r\n  }\r\n\r\n  Mass()\r\n  {\r\n    return this.m_dMass;\r\n  }\r\n\r\n  Side()\r\n  {\r\n    return new Phaser.Point(this.m_vSide.x, this.m_vSide.y);\r\n  }\r\n\r\n  MaxForce()\r\n  {\r\n    return this.m_dMaxForce;\r\n  }\r\n\r\n  SetMaxForce(mf)\r\n  {\r\n    this.m_dMaxForce = mf;\r\n  }\r\n\r\n  IsSpeedMaxedOut()\r\n  {\r\n    return this.m_dMaxSpeed * this.m_dMaxSpeed >= this.m_vVelocity.getMagnitude();\r\n  }\r\n\r\n  Speed()\r\n  {\r\n    return this.m_vVelocity.getMagnitude();\r\n  }\r\n\r\n  SpeedSq()\r\n  {\r\n    return this.m_vVelocity.getMagnitudeSq();\r\n  }\r\n\r\n  Heading()\r\n  {\r\n    return new Phaser.Point(this.m_vHeading.x, this.m_vHeading.y);\r\n  }\r\n\r\n  SetHeading(new_heading)\r\n  {\r\n    this.m_vHeading = new Phaser.Point(new_heading.x, new_heading.y);\r\n\r\n    //the side vector must always be perpendicular to the heading\r\n    this.m_vSide = new Phaser.Point(this.m_vHeading.x, this.m_vHeading.y).perp();\r\n  }\r\n\r\n  MaxTurnRate()\r\n  {\r\n    return this.m_dMaxTurnRate;\r\n  }\r\n\r\n  SetMaxTurnRate(val)\r\n  {\r\n    this.m_dMaxTurnRate = val;\r\n  }\r\n\r\n  BRadius()\r\n  {\r\n    return this.m_dBoundingRadius;\r\n  }\r\n\r\n  SetMaxSpeed(new_speed)\r\n  {\r\n    this.m_dMaxSpeed = new_speed;\r\n  }\r\n\r\n  MaxSpeed()\r\n{\r\n    return this.m_dMaxSpeed;\r\n  }\r\n\r\n  Pos()\r\n  {\r\n    return new Phaser.Point(this.m_vPosition.x, this.m_vPosition.y);\r\n  }\r\n\r\n  RotateHeadingToFacePosition(target)\r\n  {\r\n    var toTarget = new Phaser.Point(target.x - this.m_vPosition.x, target.y - this.m_vPosition.y).normalize();\r\n\r\n    var dot = this.m_vHeading.dot(toTarget);\r\n\r\n    var angle = Math.acos(dot);\r\n\r\n    //return true if the player is facing the target\r\n    if (angle < 0.00001) return true;\r\n\r\n    //clamp the amount to turn to the max turn rate\r\n    if (angle > this.m_dMaxTurnRate) angle = this.m_dMaxTurnRate;\r\n\r\n    var RotationMatrix = new Phaser.Matrix;\r\n    RotationMatrix.rotate(angle * Transformations.PointsSign(this.m_vHeading, toTarget));\r\n    this.m_vHeading = RotationMatrix.apply(this.m_vHeading);\r\n    this.m_vVelocity = RotationMatrix.apply(this.m_vVelocity);\r\n\r\n    //finally recreate m_vSide\r\n    this.m_vSide = new Phaser.Point(this.m_vHeading.x, this.m_vHeading.y).perp();\r\n\r\n    return false;\r\n  }\r\n}\r\n\r\nmodule.exports.MovingEntity = MovingEntity;\r\n","'use strict';\r\n\r\nmodule.exports.GAME_WIDTH = 684;\r\nmodule.exports.GAME_HEIGHT = 341;\r\nmodule.exports.MAP_SIZE_WIDTH = 684;\r\nmodule.exports.MAP_SIZE_HEIGHT = 341;\r\nmodule.exports.BallSize = 5;\r\nmodule.exports.BallMass = 1;\r\nmodule.exports.Friction = -0.015;\r\nmodule.exports.FrameRate = 4000;\r\nmodule.exports.GoalWidth = 100;\r\n\r\nmodule.exports.PlayerMass = 3.0;\r\nmodule.exports.PlayerMaxForce = 1.0;\r\nmodule.exports.PlayerMaxSpeedWithBall = 1.2;\r\nmodule.exports.PlayerMaxSpeedWithoutBall = 1.6;\r\nmodule.exports.PlayerMaxTurnRate = 0.4;\r\nmodule.exports.PlayerScale = 1.0;\r\n\r\nmodule.exports.ChancePlayerAttemptsPotShot = 0.005;\r\nmodule.exports.ChanceOfUsingArriveTypeReceiveBehavior = 0.5;\r\n\r\nmodule.exports.GoalKeeperTendingDistance = 20;\r\nmodule.exports.NumAttemptsToFindValidStrike = 5;\r\nmodule.exports.GoalKeeperInterceptRange = 100;\r\nmodule.exports.GoalKeeperInterceptRangeSq = module.exports.GoalKeeperInterceptRange * module.exports.GoalKeeperInterceptRange;\r\nmodule.exports.KeeperInBallRange = 10;\r\nmodule.exports.KeeperInBallRangeSq = module.exports.KeeperInBallRange * module.exports.KeeperInBallRange;\r\nmodule.exports.GoalkeeperMinPassDist = 50;\r\nmodule.exports.PlayerKickingAccuracy = 0.99;\r\nmodule.exports.BallWithinReceivingRange = 10;\r\nmodule.exports.BallWithinReceivingRangeSq = module.exports.BallWithinReceivingRange * module.exports.BallWithinReceivingRange;\r\nmodule.exports.PlayerKickingDistance = 6 + module.exports.BallSize;\r\nmodule.exports.PlayerKickingDistanceSq = module.exports.PlayerKickingDistance * module.exports.PlayerKickingDistance;\r\nmodule.exports.SeparationCoefficient = 10;\r\nmodule.exports.ViewDistance = 30;\r\nmodule.exports.PlayerComfortZone = 60;\r\nmodule.exports.PlayerComfortZoneSq = module.exports.PlayerComfortZone * module.exports.PlayerComfortZone;\r\nmodule.exports.PlayerInTargetRange = 10;\r\nmodule.exports.PlayerInTargetRangeSq = module.exports.PlayerInTargetRange * module.exports.PlayerInTargetRange;\r\n\r\nmodule.exports.NumSupportSpotsX = 13;\r\nmodule.exports.NumSupportSpotsY = 6;\r\nmodule.exports.SupportSpotUpdateFreq = 1;\r\nmodule.exports.MaxShootingForce = 6;\r\nmodule.exports.MaxDribbleForce = 1.5;\r\nmodule.exports.MinPassDist = 120.0;\r\nmodule.exports.MaxPassingForce = 3.0;\r\nmodule.exports.Spot_PassSafeScore = 2;\r\nmodule.exports.Spot_CanScoreFromPositionScore = 1;\r\nmodule.exports.Spot_DistFromControllingPlayerScore = 2;\r\nmodule.exports.PlayerKickFrequency = 8;\r\n","'use strict';\r\n\r\nvar Params = require('./Params');\r\n\r\nvar SoccerMessagesExports = require('./SoccerMessages');\r\nvar SoccerMessages = SoccerMessagesExports.SoccerMessages;\r\nvar MessageType = SoccerMessagesExports.MessageType;\r\n\r\nvar MessageDispatcherExports = require('./MessageDispatcher');\r\nvar MessageDispatcher = MessageDispatcherExports.MessageDispatcher;\r\nvar SEND_MSG_IMMEDIATELY = MessageDispatcherExports.SEND_MSG_IMMEDIATELY;\r\nvar NO_ADDITIONAL_INFO = MessageDispatcherExports.NO_ADDITIONAL_INFO;\r\nvar SENDER_ID_IRRELEVANT = MessageDispatcherExports.SENDER_ID_IRRELEVANT;\r\nvar GLOBAL_MessageDispatcher = MessageDispatcherExports.GLOBAL_MessageDispatcher;\r\n\r\nvar MovingEntityExports = require('./MovingEntity');\r\nvar MovingEntity = MovingEntityExports.MovingEntity;\r\n\r\nvar SteeringBehaviorsExports = require('./SteeringBehaviors');\r\nvar SteeringBehaviors = SteeringBehaviorsExports.SteeringBehaviors;\r\n\r\nvar AutoListExports = require('./AutoList');\r\nvar ListMembers = AutoListExports.AutoList;\r\n\r\nvar PlayerBaseEnum = {\r\n  ATTACKER: 1,\r\n  DEFENDER: 2,\r\n  GOALKEEPER: 3,\r\n};\r\n\r\nvar region_modifier = {\r\n  halfsize: 1,\r\n  normal: 2,\r\n};\r\n\r\nclass PlayerBase extends MovingEntity\r\n{\r\n  // hometeam type SoccerTeam\r\n  constructor(game, home_team, home_region, heading, velocity, mass, max_force, max_speed, max_turn_rate, scale, role)\r\n  {\r\n\r\n    super(game, home_team.Pitch().GetRegionFromIndex(home_region).Center(), scale * 10.0, velocity, max_speed, heading, mass, Phaser.Point(scale, scale), max_turn_rate, max_force);\r\n\r\n    ListMembers.push(this);\r\n\r\n    Object.defineProperty(this, 'm_pTeam', {\r\n      value: home_team,\r\n      writable: false,\r\n      enumerable: true,\r\n      configurable: true,\r\n    });\r\n\r\n    Object.defineProperty(this, 'm_iDefaultRegion', {\r\n      value: home_region,\r\n      writable: false,\r\n      enumerable: true,\r\n      configurable: true,\r\n    });\r\n\r\n    this.m_dDistSqToBall = Number.MAX_VALUE;\r\n    this.m_iHomeRegion = home_region;\r\n    this.m_PlayerRole = role;\r\n    this.m_vecPlayerVB = [];\r\n    this.m_vecPlayerVBTrans = [];\r\n\r\n    var NumPlayerVerts = 4;\r\n    var player = [new Phaser.Point(-3, 8), new Phaser.Point(3, 10), new Phaser.Point(3, -10), new Phaser.Point(-3, -8)];\r\n\r\n    for (var vtx = 0; vtx < NumPlayerVerts; ++vtx)\r\n    {\r\n      this.m_vecPlayerVB.push(player[vtx]);\r\n\r\n      //set the bounding radius to the length of the\r\n      //greatest extent\r\n      if (Math.abs(player[vtx].x) > this.m_dBoundingRadius)\r\n      {\r\n        this.m_dBoundingRadius = Math.abs(player[vtx].x);\r\n      }\r\n\r\n      if (Math.abs(player[vtx].y) > this.m_dBoundingRadius)\r\n      {\r\n        this.m_dBoundingRadius = Math.abs(player[vtx].y);\r\n      }\r\n    }\r\n\r\n    //set up the steering behavior class\r\n    this.m_pSteering = new SteeringBehaviors(this,\r\n                                        this.m_pTeam.Pitch(),\r\n                                        this.Ball());\r\n\r\n    //a player's start target is its start position (because it's just waiting)\r\n    this.m_pSteering.SetTarget(home_team.Pitch().GetRegionFromIndex(home_region).Center());\r\n  }\r\n\r\n  TrackBall()\r\n  {\r\n    this.RotateHeadingToFacePosition(this.Ball().Pos());\r\n  }\r\n\r\n  TrackTarget()\r\n  {\r\n    var diffx = this.Steering().Target().x - this.Pos().x;\r\n    var diffy = this.Steering().Target().y - this.Pos().y;\r\n\r\n    var newp = new Phaser.Point(diffx, diffy);\r\n\r\n    this.SetHeading(newp.normalize());\r\n  }\r\n\r\n  SetDefaultHomeRegion()\r\n  {this.m_iHomeRegion = this.m_iDefaultRegion;}\r\n\r\n  SortByDistanceToOpponentsGoal(p1, p2)\r\n  {\r\n    return (p1.DistToOppGoal() < p2.DistToOppGoal());\r\n  }\r\n\r\n  SortByReversedDistanceToOpponentsGoal(p1, p2)\r\n  {\r\n    return (p1.DistToOppGoal() > p2.DistToOppGoal());\r\n  }\r\n\r\n  PositionInFrontOfPlayer(position)\r\n  {\r\n    var diffx = position.x - this.Pos().x;\r\n    var diffy = position.y - this.Pos().y;\r\n    var ToSubject = new Phaser.Point(diffx, diffy);\r\n\r\n    if (ToSubject.dot(this.Heading()) > 0)\r\n    {\r\n      return true;\r\n    } else\r\n    {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  isThreatened()\r\n  {\r\n    var opp = this.Team().Opponents().Members();\r\n\r\n    for (var i = 0; i < opp.length; i++)\r\n    {\r\n      var currOpp = opp[i];\r\n\r\n      var distsq = this.Pos().distance(currOpp.Pos()) * this.Pos().distance(currOpp.Pos());\r\n\r\n      if (this.PositionInFrontOfPlayer(currOpp.Pos()) &&\r\n       (distsq < Params.PlayerComfortZoneSq))\r\n      {\r\n        return true;\r\n      }\r\n\r\n    }// next opp\r\n\r\n    return false;\r\n  }\r\n\r\n  FindSupport()\r\n  {\r\n    if (this.Team().SupportingPlayer() == null)\r\n    {\r\n      var BestSupportPly = this.Team().DetermineBestSupportingAttacker();\r\n\r\n      this.Team().SetSupportingPlayer(BestSupportPly);\r\n\r\n      GLOBAL_MessageDispatcher.DispatchMsg(\r\n         SEND_MSG_IMMEDIATELY,\r\n                              this.ID(),\r\n                              this.Team().SupportingPlayer().ID(),\r\n                              MessageType.Msg_SupportAttacker,\r\n                              null);\r\n    }\r\n\r\n    var BestSupportPly = this.Team().DetermineBestSupportingAttacker();\r\n\r\n    if (BestSupportPly && (BestSupportPly != this.Team().SupportingPlayer()))\r\n    {\r\n\r\n      if (this.Team().SupportingPlayer())\r\n      {\r\n        GLOBAL_MessageDispatcher.DispatchMsg(\r\n           SEND_MSG_IMMEDIATELY,\r\n                                this.ID(),\r\n                                this.Team().SupportingPlayer().ID(),\r\n                                MessageType.Msg_GoHome,\r\n                                null);\r\n      }\r\n\r\n      this.Team().SetSupportingPlayer(BestSupportPly);\r\n\r\n      GLOBAL_MessageDispatcher.DispatchMsg(\r\n         SEND_MSG_IMMEDIATELY,\r\n                              this.ID(),\r\n                              this.Team().SupportingPlayer().ID(),\r\n                              MessageType.Msg_SupportAttacker,\r\n                              null);\r\n    }\r\n  }\r\n\r\n  DistToOppGoal()\r\n  {\r\n    return Math.abs(this.Pos().x - this.Team().OpponentsGoal().Center().x);\r\n  }\r\n\r\n  DistToHomeGoal()\r\n  {\r\n    return Math.abs(this.Pos().x - this.Team().HomeGoal().Center().x);\r\n  }\r\n\r\n  AtTarget()\r\n  {\r\n    var distsq = this.Pos().distance(this.Steering().Target()) * this.Pos().distance(this.Steering().Target());\r\n    return (distsq < Params.PlayerInTargetRangeSq);\r\n  }\r\n\r\n  InHotRegion()\r\n  {\r\n    return Math.abs(this.Pos().y - this.Team().OpponentsGoal().Center().y) <\r\n           this.Pitch().PlayingArea().Length() / 3.0;\r\n  }\r\n\r\n  isAheadOfAttacker()\r\n  {\r\n    return Math.abs(this.Pos().x - this.Team().OpponentsGoal().Center().x) <\r\n           Math.abs(this.Team().ControllingPlayer().Pos().x - this.Team().OpponentsGoal().Center().x);\r\n  }\r\n\r\n  Role()\r\n  {\r\n    return this.m_PlayerRole;\r\n  }\r\n\r\n  Team()\r\n  {\r\n    return this.m_pTeam;\r\n  }\r\n\r\n  InHomeRegion()\r\n  {\r\n    if (this.m_PlayerRole == PlayerBaseEnum.GOALKEEPER)\r\n    {\r\n      return this.Pitch().GetRegionFromIndex(this.m_iHomeRegion).Inside(this.Pos(), region_modifier.normal);\r\n    } else\r\n    {\r\n      return this.Pitch().GetRegionFromIndex(this.m_iHomeRegion).Inside(this.Pos(), region_modifier.halfsize);\r\n    }\r\n  }\r\n\r\n  isControllingPlayer()\r\n  {\r\n    return this.Team().ControllingPlayer() === this;\r\n  }\r\n\r\n  isClosestTeamMemberToBall()\r\n  {\r\n    return this.Team().PlayerClosestToBall() === this;\r\n  }\r\n\r\n  isClosestPlayerOnPitchToBall()\r\n  {\r\n    return this.isClosestTeamMemberToBall() &&\r\n     (this.DistSqToBall() < this.Team().Opponents().ClosestDistToBallSq());\r\n  }\r\n\r\n  BallWithinKeeperRange()\r\n  {\r\n    return (this.game.math.distanceSq(this.Pos().x, this.Pos().y, this.Ball().Pos().x, this.Ball().Pos().y) < Params.KeeperInBallRangeSq);\r\n  }\r\n\r\n  BallWithinReceivingRange()\r\n  {\r\n    return (this.game.math.distanceSq(this.Pos().x, this.Pos().y, this.Ball().Pos().x, this.Ball().Pos().y) < Params.BallWithinReceivingRangeSq);\r\n  }\r\n\r\n  BallWithinKickingRange()\r\n  {\r\n    return (this.game.math.distanceSq(this.Pos().x, this.Pos().y, this.Ball().Pos().x, this.Ball().Pos().y) < Params.PlayerKickingDistanceSq);\r\n  }\r\n\r\n  SetDistSqToBall(val)\r\n  {\r\n    this.m_dDistSqToBall = val;\r\n  }\r\n\r\n  DistSqToBall()\r\n  {\r\n    return this.m_dDistSqToBall;\r\n  }\r\n\r\n  Ball()\r\n  {\r\n    return this.Team().Pitch().Ball();\r\n  }\r\n\r\n  Pitch()\r\n  {\r\n    return this.Team().Pitch();\r\n  }\r\n\r\n  HomeRegion()\r\n  {\r\n    return this.Pitch().GetRegionFromIndex(this.m_iHomeRegion);\r\n  }\r\n\r\n  SetHomeRegion(NewRegion)\r\n  {\r\n    this.m_iHomeRegion = NewRegion;\r\n  }\r\n\r\n  Steering()\r\n  {\r\n    return this.m_pSteering;\r\n  }\r\n\r\n  render()\r\n  {\r\n  }\r\n}\r\n\r\nmodule.exports.PlayerBase = PlayerBase;\r\nmodule.exports.PlayerBaseEnum = PlayerBaseEnum;\r\n","'use strict';\r\n\r\nvar Params = require('./Params');\r\n\r\nclass PrecisionTimer\r\n{\r\n  constructor(fps)\r\n  {\r\n    this.m_NormalFPS = fps;\r\n    this.m_SlowFPS = 1.0;\r\n    this.m_TimeElapsed = 0.0;\r\n    this.m_FrameTime = 0;\r\n    this.m_LastTime = 0;\r\n    this.m_LastTimeInTimeElapsed = 0;\r\n    this.m_PerfCountFreq = 0;\r\n    this.m_bStarted = false;\r\n    this.m_StartTime = 0;\r\n    this.m_LastTimeElapsed = 0.0;\r\n    this.m_bSmoothUpdates = false;\r\n\r\n    this.m_TimeScale = 1.0;\r\n    this.m_PerfCountFreq = 60000;\r\n    //calculate ticks per frame\r\n    this.m_FrameTime = parseInt(this.m_PerfCountFreq / this.m_NormalFPS);\r\n  }\r\n\r\n  Start()\r\n  {\r\n    this.m_bStarted = true;\r\n\r\n    this.m_TimeElapsed = 0.0;\r\n\r\n    //get the time\r\n    var dateobj = new Date();\r\n    this.m_LastTime = dateobj.getTime();\r\n\r\n    //keep a record of when the timer was started\r\n    this.m_StartTime = this.m_LastTime;\r\n    this.m_LastTimeInTimeElapsed = this.m_LastTime;\r\n\r\n    //update time to render next frame\r\n    this.m_NextTime = this.m_LastTime + this.m_FrameTime;\r\n\r\n    return;\r\n  }\r\n\r\n  CurrentTime()\r\n  {\r\n    var dateobj = new Date();\r\n    this.m_CurrentTime = dateobj.getTime();\r\n\r\n    return (this.m_CurrentTime - this.m_StartTime) * this.m_TimeScale;\r\n  }\r\n\r\n  Started()\r\n  {\r\n    return this.m_bStarted;\r\n  }\r\n\r\n  SmoothUpdatesOn()\r\n  {\r\n    this.m_bSmoothUpdates = true;\r\n  }\r\n\r\n  SmoothUpdatesOff()\r\n  {\r\n    this.m_bSmoothUpdates = false;\r\n  }\r\n\r\n  ReadyForNextFrame()\r\n  {\r\n    var dateobj = new Date();\r\n    this.m_CurrentTime = dateobj.getTime();\r\n\r\n    if (this.m_CurrentTime > this.m_NextTime)\r\n    {\r\n      this.m_TimeElapsed = (this.m_CurrentTime - this.m_LastTime) * this.m_TimeScale;\r\n      this.m_LastTime    = this.m_CurrentTime;\r\n\r\n      //update time to render next frame\r\n      this.m_NextTime = this.m_CurrentTime + this.m_FrameTime;\r\n\r\n      return true;\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n  TimeElapsed()\r\n  {\r\n    this.m_LastTimeElapsed = this.m_TimeElapsed;\r\n\r\n    var dateobj = new Date();\r\n    this.m_CurrentTime = dateobj.getTime();\r\n\r\n    this.m_TimeElapsed = (this.m_CurrentTime - this.m_LastTimeInTimeElapsed) * this.m_TimeScale;\r\n\r\n    this.m_LastTimeInTimeElapsed    = this.m_CurrentTime;\r\n\r\n    Smoothness = 5.0;\r\n\r\n    if (this.m_bSmoothUpdates)\r\n    {\r\n      if (this.m_TimeElapsed < (this.m_LastTimeElapsed * Smoothness))\r\n      {\r\n        return this.m_TimeElapsed;\r\n      } else\r\n      {\r\n        return 0.0;\r\n      }\r\n    } else\r\n    {\r\n      return this.m_TimeElapsed;\r\n    }\r\n  }\r\n}\r\n\r\nmodule.exports.PrecisionTimer = PrecisionTimer;\r\n","'use strict';\r\n\r\nvar region_modifier = {\r\n  halfsize: 1,\r\n  normal: 2,\r\n};\r\n\r\nclass Region\r\n{\r\n  // x coord upper left, y coord upper left, x coord lower right, y coord lower right\r\n  constructor(myleft = 0.0, mytop = 0.0, myright = 0.0, mybottom =  0.0, id = -1)\r\n  {\r\n    Object.defineProperty(this, 'm_dTop', {\r\n      value: mytop,\r\n      writable: false,\r\n      enumerable: true,\r\n      configurable: true,\r\n    });\r\n\r\n    Object.defineProperty(this, 'm_dRight', {\r\n      value: myright,\r\n      writable: false,\r\n      enumerable: true,\r\n      configurable: true,\r\n    });\r\n\r\n    Object.defineProperty(this, 'm_dLeft', {\r\n      value: myleft,\r\n      writable: false,\r\n      enumerable: true,\r\n      configurable: true,\r\n    });\r\n\r\n    Object.defineProperty(this, 'm_dBottom', {\r\n      value: mybottom,\r\n      writable: false,\r\n      enumerable: true,\r\n      configurable: true,\r\n    });\r\n\r\n    Object.defineProperty(this, 'm_iID', {\r\n      value: id,\r\n      writable: false,\r\n      enumerable: true,\r\n      configurable: true,\r\n    });\r\n\r\n    Object.defineProperty(this, 'm_vCenter', {\r\n      value: new Phaser.Point((this.m_dLeft + this.m_dRight) * 0.5, (this.m_dTop + this.m_dBottom) * 0.5),\r\n      writable: false,\r\n      enumerable: true,\r\n      configurable: true,\r\n    });\r\n\r\n    Object.defineProperty(this, 'm_dWidth', {\r\n      value: Math.abs(this.m_dRight - this.m_dLeft),\r\n      writable: false,\r\n      enumerable: true,\r\n      configurable: true,\r\n    });\r\n\r\n    Object.defineProperty(this, 'm_dHeight', {\r\n      value: Math.abs(this.m_dBottom - this.m_dRight),\r\n      writable: false,\r\n      enumerable: true,\r\n      configurable: true,\r\n    });\r\n  }\r\n\r\n  Top()\r\n  {\r\n    return this.m_dTop;\r\n  }\r\n\r\n  Bottom()\r\n  {\r\n    return this.m_dBottom;\r\n  }\r\n\r\n  Left()\r\n  {\r\n    return this.m_dLeft;\r\n  }\r\n\r\n  Right()\r\n  {\r\n    return this.m_dRight;\r\n  }\r\n\r\n  Width()\r\n  {\r\n    return Math.abs(this.m_dRight - this.m_dLeft);\r\n  }\r\n\r\n  Height()\r\n  {\r\n    return Math.abs(this.m_dTop - this.m_dBottom);\r\n  }\r\n\r\n  Length()\r\n  {\r\n    return Math.max(this.Width(), this.Height());\r\n  }\r\n\r\n  Breadth()\r\n  {\r\n    return Math.min(this.Width(), this.Height());\r\n  }\r\n\r\n  Center()\r\n  {\r\n    return new Phaser.Point(this.m_vCenter.x, this.m_vCenter.y);\r\n  }\r\n\r\n  ID()\r\n  {\r\n    return this.m_iID;\r\n  }\r\n\r\n  GetRandomPosition()\r\n  {\r\n    var x = Math.floor((Math.random() * this.m_dRight) + this.m_dLeft);\r\n    var y = Math.floor((Math.random() * this.m_dBottom) + this.m_dTop);\r\n    return x;\r\n  }\r\n\r\n  Inside(pos, r = region_modifier.normal)\r\n  {\r\n    if (r == region_modifier.normal)\r\n    {\r\n      return ((pos.x > this.m_dLeft) && (pos.x < this.m_dRight) &&\r\n        (pos.y > this.m_dTop) && (pos.y < this.m_dBottom));\r\n    } else\r\n    {\r\n      var marginX = this.m_dWidth * 0.25;\r\n      var marginY = this.m_dHeight * 0.25;\r\n\r\n      return ((pos.x > (this.m_dLeft + marginX)) && (pos.x < (this.m_dRight - marginX)) &&\r\n        (pos.y > (this.m_dTop + marginY)) && (pos.y < (this.m_dBottom - marginY)));\r\n    }\r\n  }\r\n\r\n  Render(graphics)\r\n  {\r\n    // top line\r\n    graphics.moveTo(this.m_dLeft, this.m_dTop);\r\n    graphics.lineTo(this.m_dRight, this.m_dTop);\r\n\r\n    // left line\r\n    graphics.moveTo(this.m_dLeft, this.m_dTop);\r\n    graphics.lineTo(this.m_dLeft, this.m_dBottom);\r\n\r\n    // right line\r\n    graphics.moveTo(this.m_dRight, this.m_dTop);\r\n    graphics.lineTo(this.m_dRight, this.m_dBottom);\r\n\r\n    // bottom line\r\n    graphics.moveTo(this.m_dLeft, this.m_dBottom);\r\n    graphics.lineTo(this.m_dRight, this.m_dBottom);\r\n  }\r\n}\r\n/*\r\n\r\ninline void Region::Render(bool ShowID = 0)const\r\n{\r\n  gdi->HollowBrush();\r\n  gdi->GreenPen();\r\n  gdi->Rect(m_dLeft, m_dTop, m_dRight, m_dBottom);\r\n\r\n  if (ShowID)\r\n  {\r\n    gdi->TextColor(Cgdi::green);\r\n    gdi->TextAtPos(Center(), ttos(ID()));\r\n  }\r\n}\r\n*/\r\n\r\nmodule.exports.Region = Region;\r\nmodule.exports.region_modifier = region_modifier;\r\n","'use strict';\r\n\r\nfunction getRandomArbitrary(min, max)\r\n{\r\n  return Math.random() * (max - min) + min;\r\n}\r\n\r\nclass Regulator\r\n{\r\n  // hometeam type SoccerTeam\r\n  constructor(NumUpdatesPerSecondRqd)\r\n  {\r\n    var d = new Date();\r\n    var n = d.getTime();\r\n\r\n    this.m_dwNextUpdateTime = (n + Math.random() * 1000);\r\n\r\n    if (NumUpdatesPerSecondRqd > 0)\r\n    {\r\n      this.m_dUpdatePeriod = 1000.0 / NumUpdatesPerSecondRqd;\r\n    } else if (0 == NumUpdatesPerSecondRqd)\r\n    {\r\n      this.m_dUpdatePeriod = 0.0;\r\n    } else if (NumUpdatesPerSecondRqd < 0)\r\n    {\r\n      this.m_dUpdatePeriod = -1;\r\n    }\r\n  }\r\n\r\n\r\n  //returns true if the current time exceeds m_dwNextUpdateTime\r\n  isReady()\r\n  {\r\n    //if a regulator is instantiated with a zero freq then it goes into\r\n    //stealth mode (doesn't regulate)\r\n    if (0 == this.m_dUpdatePeriod) return true;\r\n\r\n    //if the regulator is instantiated with a negative freq then it will\r\n    //never allow the code to flow\r\n    if (this.m_dUpdatePeriod < 0) return false;\r\n\r\n    var d = new Date();\r\n    var CurrentTime = d.getTime();\r\n\r\n    //the number of milliseconds the update period can vary per required\r\n    //update-step. This is here to make sure any multiple clients of this class\r\n    //have their updates spread evenly\r\n    var UpdatePeriodVariator = 10.0;\r\n\r\n    if (CurrentTime >= this.m_dwNextUpdateTime)\r\n    {\r\n      this.m_dwNextUpdateTime = (CurrentTime + this.m_dUpdatePeriod + getRandomArbitrary(-UpdatePeriodVariator, UpdatePeriodVariator));\r\n\r\n      return true;\r\n    }\r\n\r\n    return false;\r\n  }\r\n}\r\n\r\nmodule.exports.Regulator = Regulator;\r\n","'use strict';\r\n\r\nvar MovingEntityExports = require('./MovingEntity');\r\nvar MovingEntity = MovingEntityExports.MovingEntity;\r\n\r\nvar TransformationsExports = require('./Transformations');\r\nvar Transformations = TransformationsExports.Transformations;\r\n\r\nvar Params = require('./Params');\r\n\r\nvar span_type = {\r\n  plane_backside: 1,\r\n  plane_front: 2,\r\n  on_plane: 3,\r\n};\r\n\r\nfunction WhereIsPoint(point, PointOnPlane, PlaneNormal)\r\n{\r\n  var dir = new Phaser.Point(PointOnPlane.x - point.x, PointOnPlane.y - point.y);\r\n\r\n  var d = dir.dot(PlaneNormal);\r\n\r\n  if (d < -0.000001)\r\n  {\r\n    return span_type.plane_front;\r\n  } else if (d > 0.000001)\r\n  {\r\n    return span_type.plane_backside;\r\n  }\r\n\r\n  return span_type.on_plane;\r\n}\r\n\r\nfunction DistanceToRayPlaneIntersection(RayOrigin, RayHeading, PlanePoint, PlaneNormal)\r\n{\r\n  var d     = -PlaneNormal.dot(PlanePoint);\r\n  var numer = PlaneNormal.dot(RayOrigin) + d;\r\n  var denom = PlaneNormal.dot(RayHeading);\r\n\r\n  // normal is parallel to vector\r\n  if ((denom < 0.000001) && (denom > -0.000001))\r\n  {\r\n    return (-1.0);\r\n  }\r\n\r\n  return -(numer / denom);\r\n}\r\n\r\nclass SoccerBall extends MovingEntity\r\n{\r\n  // pos ballsize mass pitchboundary\r\n  constructor(game, pos, BallSize, mass, PitchBoundary)\r\n  {\r\n    super(game, pos, BallSize, new Phaser.Point(0, 0), -1, new Phaser.Point(0, 1), mass, new Phaser.Point(1, 1), 0, 0);\r\n\r\n    this.m_PitchBoundary = PitchBoundary;\r\n  }\r\n\r\n  //---------------------- TimeToCoverDistance -----------------------------\r\n  //\r\n  //  Given a force and a distance to cover given by two vectors, this\r\n  //  method calculates how long it will take the ball to travel between\r\n  //  the two points\r\n  //------------------------------------------------------------------------\r\n  TimeToCoverDistance(A, B, force)\r\n  {\r\n    //this will be the velocity of the ball in the next time step *if*\r\n    //the player was to make the pass.\r\n    var speed = force / this.m_dMass;\r\n\r\n    //calculate the velocity at B using the equation\r\n    //\r\n    //  v^2 = u^2 + 2as\r\n    //\r\n\r\n    //first calculate s (the distance between the two positions)\r\n    var DistanceToCover =  A.distance(B);\r\n\r\n    var term = speed * speed + 2.0 * DistanceToCover * Params.Friction;\r\n\r\n    //if  (u^2 + 2as) is negative it means the ball cannot reach point B.\r\n    if (term <= 0.0) return -1.0;\r\n\r\n    var v = Math.sqrt(term);\r\n\r\n    //it IS possible for the ball to reach B and we know its speed when it\r\n    //gets there, so now it's easy to calculate the time using the equation\r\n    //\r\n    //    t = v-u\r\n    //        ---\r\n    //         a\r\n    //\r\n    return (v - speed) / Params.Friction;\r\n  }\r\n\r\n  Render(game)\r\n  {\r\n    this.sprite = game.add.sprite(this.m_vPosition.x, this.m_vPosition.y, 'ball');\r\n    this.sprite.anchor.setTo(0.5, 0.5);\r\n    this.sprite.scale.setTo(0.2, 0.2);\r\n  }\r\n\r\n  static getRandomArbitrary(min, max) {\r\n    return Math.random() * (max - min) + min;\r\n  }\r\n\r\n  static AddNoiseToKick(BallPos, BallTarget)\r\n  {\r\n\r\n    var displacement = (Math.PI - Math.PI * Params.PlayerKickingAccuracy) * SoccerBall.getRandomArbitrary(-1, 1);\r\n\r\n    var toTarget = new Phaser.Point(BallTarget.x - BallPos.x, BallTarget.y - BallPos.y);\r\n\r\n    //toTarget.rotation += displacement;\r\n\r\n    toTarget.rotate(0, 0, displacement);\r\n\r\n    return new Phaser.Point(toTarget.x + BallPos.x, toTarget.y + BallPos.y);\r\n  }\r\n\r\n  Kick(direction, force)\r\n  {\r\n    //ensure direction is normalized\r\n    direction.normalize();\r\n\r\n    //calculate the acceleration\r\n    var acceleration_x = (direction.x * force) / this.m_dMass;\r\n    var acceleration_y = (direction.y * force) / this.m_dMass;\r\n\r\n    //update the velocity\r\n    this.m_vVelocity = new Phaser.Point(acceleration_x, acceleration_y);\r\n  }\r\n\r\n  Update(game)\r\n  {\r\n    //keep a record of the old position so the goal::scored method\r\n    //can utilize it for goal testing\r\n    this.m_vOldPos = new Phaser.Point(this.m_vPosition.x, this.m_vPosition.y);\r\n\r\n    this.sprite.x = this.m_vPosition.x;\r\n    this.sprite.y = this.m_vPosition.y;\r\n\r\n\r\n    //Test for collisions\r\n    this.TestCollisionWithWalls(this.m_PitchBoundary);\r\n\r\n    //Simulate Prm.Friction. Make sure the speed is positive\r\n    //first though\r\n\r\n    if (this.m_vVelocity.getMagnitudeSq() > (Params.Friction * Params.Friction))\r\n    {\r\n      var temp = new Phaser.Point(this.m_vVelocity.x, this.m_vVelocity.y).normalize();\r\n      this.m_vVelocity.add(temp.x * Params.Friction, temp.y * Params.Friction);\r\n      this.m_vPosition.add(this.m_vVelocity.x, this.m_vVelocity.y);\r\n\r\n      //update heading\r\n      this.m_vHeading = new Phaser.Point(this.m_vVelocity.x, this.m_vVelocity.y).normalize();\r\n    }\r\n\r\n  }\r\n\r\n  TimeToCoverDistance(A, B, force)\r\n  {\r\n    //this will be the velocity of the ball in the next time step *if*\r\n    //the player was to make the pass.\r\n    var speed = force / this.m_dMass;\r\n\r\n    //calculate the velocity at B using the equation\r\n    //\r\n    //  v^2 = u^2 + 2as\r\n    //\r\n\r\n    //first calculate s (the distance between the two positions)\r\n\r\n    var DistanceToCover =  A.distance(B);\r\n\r\n    var term = speed * speed + 2.0 * DistanceToCover * Params.Friction;\r\n\r\n    //if  (u^2 + 2as) is negative it means the ball cannot reach point B.\r\n    if (term <= 0.0) return -1.0;\r\n\r\n    var v = Math.sqrt(term);\r\n\r\n    //it IS possible for the ball to reach B and we know its speed when it\r\n    //gets there, so now it's easy to calculate the time using the equation\r\n    //\r\n    //    t = v-u\r\n    //        ---\r\n    //         a\r\n    //\r\n    return (v - speed) / Params.Friction;\r\n  }\r\n\r\n  FuturePosition(time)\r\n  {\r\n    //using the equation s = ut + 1/2at^2, where s = distance, a = friction\r\n    //u=start velocity\r\n\r\n    //calculate the ut term, which is a vector\r\n    var utx = this.m_vVelocity.x * time;\r\n    var uty = this.m_vVelocity.y * time;\r\n\r\n    //calculate the 1/2at^2 term, which is scalar\r\n    var half_a_t_squared = 0.5 * Params.Friction * time * time;\r\n\r\n    //turn the scalar quantity into a vector by multiplying the value with\r\n    //the normalized velocity vector (because that gives the direction)\r\n    var norm = new Phaser.Point(this.m_vVelocity.x, this.m_vVelocity.y).normalize();\r\n    var ScalarToVectorx = half_a_t_squared * norm.x;\r\n    var ScalarToVectory = half_a_t_squared * norm.y;\r\n\r\n    //the predicted position is the balls position plus these two terms\r\n    return new Phaser.Point(this.Pos().x + utx + ScalarToVectorx, this.Pos().y + uty + ScalarToVectory);\r\n  }\r\n\r\n  TestCollisionWithWalls(walls)\r\n  {\r\n    //test ball against each wall, find out which is closest\r\n    var idxClosest = -1;\r\n\r\n    var VelNormal = new Phaser.Point(this.m_vVelocity.x, this.m_vVelocity.y).normalize();\r\n\r\n    var IntersectionPoint;\r\n    var CollisionPoint;\r\n\r\n    var DistToIntersection = Number.MAX_VALUE;\r\n\r\n    //iterate through each wall and calculate if the ball intersects.\r\n    //If it does then store the index into the closest intersecting wall\r\n    for (var w = 0; w < walls.length; ++w)\r\n    {\r\n      //assuming a collision if the ball continued on its current heading\r\n      //calculate the point on the ball that would hit the wall. This is\r\n      //simply the wall's normal(inversed) multiplied by the ball's radius\r\n      //and added to the balls center (its position)\r\n      var ThisCollisionPoint = new Phaser.Point(this.Pos().x - (walls[w].Normal().x * this.BRadius()), this.Pos().y - (walls[w].Normal().y * this.BRadius()));\r\n\r\n      //calculate exactly where the collision point will hit the plane\r\n      if (WhereIsPoint(ThisCollisionPoint,\r\n\t\t      walls[w].From(),\r\n\t\t      walls[w].Normal()) == span_type.plane_backside)\r\n      {\r\n        var DistToWall = DistanceToRayPlaneIntersection(ThisCollisionPoint,\r\n             walls[w].Normal(),\r\n             walls[w].From(),\r\n             walls[w].Normal());\r\n\r\n        IntersectionPoint = Phaser.Point.add(ThisCollisionPoint, new Phaser.Point(DistToWall * walls[w].Normal().x, DistToWall * walls[w].Normal().y));\r\n\r\n      } else\r\n      {\r\n        var DistToWall = DistanceToRayPlaneIntersection(ThisCollisionPoint,\r\n             VelNormal,\r\n             walls[w].From(),\r\n             walls[w].Normal());\r\n\r\n        IntersectionPoint = Phaser.Point.add(ThisCollisionPoint, new Phaser.Point(DistToWall * VelNormal, DistToWall * VelNormal));\r\n\r\n      }\r\n\r\n      //check to make sure the intersection point is actually on the line\r\n      //segment\r\n      var OnLineSegment = false;\r\n\r\n      var line1 = new Phaser.Line(walls[w].From().x, walls[w].From().y, walls[w].To().x, walls[w].To().y);\r\n      var line2 = new Phaser.Line(ThisCollisionPoint.x - walls[w].Normal().x * 20.0, ThisCollisionPoint.y - walls[w].Normal().y * 20.0, ThisCollisionPoint.x + walls[w].Normal().x * 20.0, ThisCollisionPoint.y + walls[w].Normal().y * 20.0);\r\n\r\n      line1.intersects(line2, true);\r\n\r\n      if (line1.intersects(line2, true))\r\n      {\r\n\r\n        OnLineSegment = true;\r\n      }\r\n\r\n\r\n      //Note, there is no test for collision with the end of a line segment\r\n\r\n      //now check to see if the collision point is within range of the\r\n      //velocity vector. [work in distance squared to avoid sqrt] and if it\r\n      //is the closest hit found so far.\r\n      //If it is that means the ball will collide with the wall sometime\r\n      //between this time step and the next one.\r\n      var distSq = ThisCollisionPoint.distance(IntersectionPoint) * ThisCollisionPoint.distance(IntersectionPoint);\r\n\r\n      if ((distSq <= this.m_vVelocity.getMagnitudeSq()) && (distSq < DistToIntersection) && OnLineSegment)\r\n      {\r\n        DistToIntersection = distSq;\r\n        idxClosest = w;\r\n        CollisionPoint = IntersectionPoint;\r\n      }\r\n    }//next wall\r\n\r\n\r\n    //to prevent having to calculate the exact time of collision we\r\n    //can just check if the velocity is opposite to the wall normal\r\n    //before reflecting it. This prevents the case where there is overshoot\r\n    //and the ball gets reflected back over the line before it has completely\r\n    //reentered the playing area.\r\n    if ((idxClosest >= 0) && VelNormal.dot(walls[idxClosest].Normal()) < 0)\r\n    {\r\n      Transformations.Reflect(this.m_vVelocity, walls[idxClosest].Normal());\r\n    }\r\n  }\r\n\r\n  PlaceAtPosition(NewPos)\r\n  {\r\n    this.m_vOldPos = new Phaser.Point(this.m_vPosition.x, this.m_vPosition.y);\r\n\r\n    this.m_vPosition = new Phaser.Point(NewPos.x, NewPos.y);\r\n\r\n    this.m_vVelocity.setTo(0, 0);\r\n  }\r\n\r\n  HandleMessage(msg) {return false;}\r\n\r\n  Trap() {\r\n\r\n    this.m_vVelocity.setTo(0, 0);}\r\n\r\n  OldPos() {return new Phaser.Point(this.m_vOldPos.x, this.m_vOldPos.y);}\r\n}\r\n\r\nmodule.exports.SoccerBall = SoccerBall;\r\n","'use strict';\r\n\r\nvar MessageType = {\r\n  Msg_ReceiveBall: 1,\r\n  Msg_PassToMe: 2,\r\n  Msg_SupportAttacker: 3,\r\n  Msg_GoHome: 4,\r\n  Msg_Wait: 5,\r\n};\r\n\r\nclass SoccerMessages\r\n{\r\n  constructor()\r\n  {\r\n  }\r\n\r\n  MessageToString(msg)\r\n  {\r\n    switch (msg)\r\n    {\r\n    case MessageType.Msg_ReceiveBall:\r\n      return 'Msg_ReceiveBall';\r\n\r\n    case MessageType.Msg_PassToMe:\r\n      return 'Msg_PassToMe';\r\n\r\n    case MessageType.Msg_SupportAttacker:\r\n      return 'Msg_SupportAttacker';\r\n\r\n    case MessageType.Msg_GoHome:\r\n      return 'Msg_GoHome';\r\n\r\n    case MessageType.Msg_Wait:\r\n      return 'Msg_Wait';\r\n\r\n    default:\r\n      return 'INVALID MESSAGE!!';\r\n  }\r\n  }\r\n}\r\n\r\nmodule.exports.SoccerMessages = SoccerMessages;\r\nmodule.exports.MessageType = MessageType;\r\n","'use strict';\r\n\r\nvar RegionExports = require('./Region');\r\nvar Region = RegionExports.Region;\r\n\r\nvar GoalExports = require('./Goal');\r\nvar Goal = GoalExports.Goal;\r\n\r\nvar SoccerBallExports = require('./SoccerBall');\r\nvar SoccerBall = SoccerBallExports.SoccerBall;\r\n\r\nvar SoccerTeamExports = require('./SoccerTeam');\r\nvar SoccerTeam = SoccerTeamExports.SoccerTeam;\r\n\r\nvar ColorTeamExports = require('./ColorTeam');\r\nvar ColorTeam = ColorTeamExports.ColorTeam;\r\n\r\nvar Wall2DExports = require('./Wall2D');\r\nvar Wall2D = Wall2DExports.Wall2D;\r\n\r\nvar EntityManagerExports = require('./EntityManager');\r\nvar EntityManager = EntityManagerExports.EntityManager;\r\n\r\nvar TeamStatesExports = require('./TeamStates');\r\nvar Attacking = TeamStatesExports.Attacking;\r\nvar Defending = TeamStatesExports.Defending;\r\nvar PrepareForKickOff = TeamStatesExports.PrepareForKickOff;\r\n\r\nvar Params = require('./Params');\r\n\r\nclass SoccerPitch\r\n{\r\n  constructor(game, width, height)\r\n  {\r\n    this.m_pBall = true;\r\n    this.m_pRedTeam = true;\r\n    this.m_pBlueTeam = true;\r\n    this.m_pRedGoal = true;\r\n    this.m_pBlueGoal = true;\r\n\r\n    Object.defineProperty(this, 'm_cxClient', {\r\n      value: width,\r\n      writable: false,\r\n      enumerable: true,\r\n      configurable: true,\r\n    });\r\n\r\n    Object.defineProperty(this, 'm_cyClient', {\r\n      value: height,\r\n      writable: false,\r\n      enumerable: true,\r\n      configurable: true,\r\n    });\r\n\r\n    Object.defineProperty(this, 'm_BallSize', {\r\n      value: Params.BallSize,\r\n      writable: false,\r\n      enumerable: true,\r\n      configurable: true,\r\n    });\r\n\r\n    Object.defineProperty(this, 'm_BallMass', {\r\n      value: Params.BallMass,\r\n      writable: false,\r\n      enumerable: true,\r\n      configurable: true,\r\n    });\r\n\r\n    // goalwidth = height in coordinates system\r\n    //this.m_GoalWidth = height / 9.3;\r\n\r\n    this.m_vecWalls = [];\r\n    this.m_pPlayingArea = true;\r\n    this.m_Regions = [];\r\n\r\n    this.m_bGameOn = true;\r\n    this.m_bGoalKeeperHasBall = false;\r\n    this.m_bPaused = false;\r\n\r\n\r\n    // left top right bottom\r\n    this.m_pPlayingArea = new Region(20, 20, this.m_cxClient - 20, this.m_cyClient - 20);\r\n\r\n    var NumRegionsHorizontal = 6;\r\n    var NumRegionsVertical = 3;\r\n\r\n    this.CreateRegions(NumRegionsHorizontal * NumRegionsVertical, NumRegionsHorizontal, NumRegionsVertical);\r\n    /*\r\n    this.CreateRegions(this.m_pPlayingArea.Width() / NumRegionsHorizontal, this.m_pPlayingArea.Height() / NumRegionsVertical);\r\n    */\r\n\r\n\r\n    //create the goals\r\n    this.m_pRedGoal  = new Goal(\r\n         new Phaser.Point(this.m_pPlayingArea.Left(), (this.m_cyClient - Params.GoalWidth) / 2),\r\n         new Phaser.Point(this.m_pPlayingArea.Left(), this.m_cyClient - (this.m_cyClient - Params.GoalWidth) / 2),\r\n         new Phaser.Point(1, 0));\r\n\r\n    this.m_pBlueGoal = new Goal(\r\n         new Phaser.Point(this.m_pPlayingArea.Right(), (this.m_cyClient - Params.GoalWidth) / 2),\r\n         new Phaser.Point(this.m_pPlayingArea.Right(), this.m_cyClient - (this.m_cyClient - Params.GoalWidth) / 2),\r\n         new Phaser.Point(-1, 0));\r\n\r\n    //create the soccer ball\r\n    this.m_pBall = new SoccerBall(game, new Phaser.Point(this.m_cxClient / 2.0, this.m_cyClient / 2.0), Params.BallSize, Params.BallMass, this.m_vecWalls);\r\n\r\n    //create the teams\r\n    this.m_pRedTeam  = new SoccerTeam(game, this.m_pRedGoal, this.m_pBlueGoal, this, ColorTeam.RED);\r\n    this.m_pBlueTeam = new SoccerTeam(game, this.m_pBlueGoal, this.m_pRedGoal, this, ColorTeam.BLUE);\r\n\r\n\r\n    //make sure each team knows who their opponents are\r\n    this.m_pRedTeam.SetOpponents(this.m_pBlueTeam);\r\n    this.m_pBlueTeam.SetOpponents(this.m_pRedTeam);\r\n\r\n    var TopLeft = new Phaser.Point(this.m_pPlayingArea.Left(), this.m_pPlayingArea.Top());\r\n    var TopRight = new Phaser.Point(this.m_pPlayingArea.Right(), this.m_pPlayingArea.Top());\r\n    var BottomRight = new Phaser.Point(this.m_pPlayingArea.Right(), this.m_pPlayingArea.Bottom());\r\n    var BottomLeft = new Phaser.Point(this.m_pPlayingArea.Left(), this.m_pPlayingArea.Bottom());\r\n\r\n    this.m_vecWalls.push(new Wall2D(BottomLeft, this.m_pRedGoal.RightPost()));\r\n    this.m_vecWalls.push(new Wall2D(this.m_pRedGoal.LeftPost(), TopLeft));\r\n    this.m_vecWalls.push(new Wall2D(TopLeft, TopRight));\r\n    this.m_vecWalls.push(new Wall2D(TopRight, this.m_pBlueGoal.LeftPost()));\r\n    this.m_vecWalls.push(new Wall2D(this.m_pBlueGoal.RightPost(), BottomRight));\r\n    this.m_vecWalls.push(new Wall2D(BottomRight, BottomLeft));\r\n  }\r\n\r\n  GoalKeeperHasBall() {return this.m_bGoalKeeperHasBall;}\r\n\r\n  SetGoalKeeperHasBall(b)\r\n  {\r\n    this.m_bGoalKeeperHasBall = b;\r\n  }\r\n\r\n  Walls() {return m_vecWalls;}\r\n\r\n  CreateRegions(size, NumRegionsHorizontal, NumRegionsVertical)\r\n  {\r\n    var width = this.m_pPlayingArea.Width() / NumRegionsHorizontal;\r\n    var height = this.m_pPlayingArea.Height() / NumRegionsVertical;\r\n\r\n    var idx = size - 1;\r\n\r\n    for (var col = 0; col < NumRegionsHorizontal; ++col)\r\n    {\r\n      for (var row = 0; row < NumRegionsVertical; ++row)\r\n      {\r\n        this.m_Regions[idx] = new Region(this.m_pPlayingArea.Left() + col * width,\r\n                this.m_pPlayingArea.Top() + row * height,\r\n                this.m_pPlayingArea.Left() + (col + 1) * width,\r\n                this.m_pPlayingArea.Top() + (row + 1) * height,\r\n                idx);\r\n        console.dir('CreateRegions');\r\n        console.dir(JSON.stringify(this.m_Regions[idx]));\r\n\r\n       idx--;\r\n      }\r\n    }\r\n  }\r\n\r\n  PlayingArea()\r\n  {\r\n    return this.m_pPlayingArea;\r\n  }\r\n\r\n  GetRegionFromIndex(idx)\r\n  {\r\n    if (idx >= 0 && idx < this.m_Regions.length)\r\n     return this.m_Regions[idx];\r\n\r\n    return null;\r\n  }\r\n\r\n  Ball()\r\n  {\r\n    return this.m_pBall;\r\n  }\r\n\r\n  GameOn()\r\n  {\r\n    return this.m_bGameOn;\r\n  }\r\n\r\n  SetGameOn()\r\n  {\r\n    this.m_bGameOn = true;\r\n  }\r\n\r\n  SetGameOff()\r\n  {\r\n    this.m_bGameOn = false;\r\n  }\r\n\r\n  TogglePause() {m_bPaused = !m_bPaused;}\r\n\r\n  Paused() {return this.m_bPaused;}\r\n\r\n  cxClient() {return new Number(this.m_cxClient);}\r\n\r\n  cyClient() {return new Number(this.m_cyClient);}\r\n\r\n  Update(game)\r\n  {\r\n    if (this.m_bPaused)\r\n     return;\r\n\r\n    var tick = 0;\r\n\r\n    //update the balls\r\n    this.m_pBall.Update(game);\r\n\r\n    //update the teams\r\n    this.m_pRedTeam.Update(game);\r\n    this.m_pBlueTeam.Update(game);\r\n\r\n    //if a goal has been detected reset the pitch ready for kickoff\r\n    if (this.m_pBlueGoal.Scored(this.m_pBall) || this.m_pRedGoal.Scored(this.m_pBall))\r\n    {\r\n      this.m_bGameOn = false;\r\n\r\n      //reset the ball\r\n      this.m_pBall.PlaceAtPosition(new Phaser.Point(this.m_cxClient / 2.0, this.m_cyClient / 2.0));\r\n\r\n      //get the teams ready for kickoff\r\n      this.m_pRedTeam.GetFSM().ChangeState(new PrepareForKickOff());\r\n      this.m_pBlueTeam.GetFSM().ChangeState(new PrepareForKickOff());\r\n    }\r\n\r\n  }\r\n\r\n  Render(game)\r\n  {\r\n    this.m_pBall.m_dBoundingRadius = this.m_BallSize;\r\n    // pitch\r\n    game.stage.backgroundColor =  '#006600';\r\n\r\n    var graphics = game.add.graphics(0, 0);\r\n    graphics.lineStyle(2, 0x2E2E2E, 1);\r\n\r\n    // regions\r\n    /*\r\n    if (Prm.bRegions)\r\n    {   */\r\n    for (var r = 0; r < this.m_Regions.length; r++)\r\n    {\r\n      this.m_Regions[r].Render(graphics);\r\n    }\r\n    //}\r\n\r\n    // goals\r\n    //lineStyle(lineWidth, color, alpha)\r\n    graphics.lineStyle(2, 0xB40404, 1);\r\n    //drawRect(x, y, width, height)\r\n    graphics.drawRect(this.m_pPlayingArea.Left() - 20, (this.m_cyClient - Params.GoalWidth) / 2, 20, Params.GoalWidth);\r\n    graphics.lineStyle(2, 0x0404B4, 1);\r\n    graphics.drawRect(this.m_pPlayingArea.Right(), (this.m_cyClient - Params.GoalWidth) / 2, 20, Params.GoalWidth);\r\n\r\n    // walls\r\n    graphics.lineStyle(2, 0xFFFFFF, 1);\r\n    graphics.beginFill(0xFFFFFF);\r\n    for (var w = 0; w < this.m_vecWalls.length; w++)\r\n    {\r\n      this.m_vecWalls[w].Render(graphics);\r\n    }\r\n\r\n    graphics.endFill();\r\n\r\n    // marks pitch\r\n    graphics.drawCircle(this.m_pPlayingArea.Center().x, this.m_pPlayingArea.Center().y, this.m_pPlayingArea.Width() * 0.125);\r\n    graphics.drawCircle(this.m_pPlayingArea.Center().x, this.m_pPlayingArea.Center().y, 2);\r\n\r\n    graphics.beginFill(0xFFFFFF);\r\n    graphics.moveTo(this.m_pPlayingArea.Center().x, this.m_pPlayingArea.Top());\r\n    graphics.lineTo(this.m_pPlayingArea.Center().x, this.m_pPlayingArea.Bottom());\r\n    graphics.endFill();\r\n\r\n    //Render the teams\r\n    this.m_pRedTeam.Render(game);\r\n    this.m_pBlueTeam.Render(game);\r\n\r\n    // ball\r\n    this.m_pBall.Render(game);\r\n  }\r\n}\r\n\r\nmodule.exports.SoccerPitch = SoccerPitch;\r\n/*\r\ndimensions d'une tile = 32*32)\r\nlongueur = 105 m (8pixels * 105 = 840)\r\nlargeur = 68 m (8pixels * 68 = 544)\r\n\r\nligne d'engagement : |0|51m|52|51m|104|\r\n\r\nsurface de rparation = 40*16\r\nbut = 7,3*2,4\r\n\r\npoint de penalty = 11m\r\n\r\nsurface de but = 5,5\r\n\r\n\r\n*/\r\n","\"use strict\"; \r\n\r\nvar StateMachineExports = require('./StateMachine');\r\nvar StateMachine = StateMachineExports.StateMachine;\r\n\r\nvar GoalkeeperExports = require('./Goalkeeper');\r\nvar Goalkeeper = GoalkeeperExports.Goalkeeper;\r\n\r\nvar PlayerBaseExports = require('./PlayerBase');\r\nvar PlayerBase = PlayerBaseExports.PlayerBase;\r\nvar PlayerBaseEnum = PlayerBaseExports.PlayerBaseEnum;\r\n\r\nvar FieldPlayerExports = require('./FieldPlayer');\r\nvar FieldPlayer = FieldPlayerExports.FieldPlayer;\r\n\r\nvar ColorTeamExports = require('./ColorTeam');\r\nvar ColorTeam = ColorTeamExports.ColorTeam;\r\n\r\nvar SupportSpotCalculatorExports = require('./SupportSpotCalculator');\r\nvar SupportSpotCalculator = SupportSpotCalculatorExports.SupportSpotCalculator;\r\n\r\nvar GoalkeeperStatesExports = require('./GoalkeeperStates');\r\nvar GoalkeeperStates = GoalkeeperStatesExports.GoalkeeperStates;\r\nvar TendGoal = GoalkeeperStatesExports.TendGoal;\r\nvar ReturnHome = GoalkeeperStatesExports.ReturnHome;\r\nvar InterceptBall = GoalkeeperStatesExports.InterceptBall;\r\nvar PutBallBackInPlay = GoalkeeperStatesExports.PutBallBackInPlay;\r\n\r\nvar FieldPlayerStatesExports = require('./FieldPlayerStates');\r\nvar FieldPlayerStates = FieldPlayerStatesExports.FieldPlayerStates;\r\nvar Wait = FieldPlayerStatesExports.Wait;\r\nvar ReturnToHomeRegion = FieldPlayerStatesExports.ReturnToHomeRegion;\r\n\r\nvar TeamStatesExports = require('./TeamStates');\r\nvar Attacking = TeamStatesExports.Attacking;\r\nvar Defending = TeamStatesExports.Defending;\r\nvar PrepareForKickOff = TeamStatesExports.PrepareForKickOff;\r\n\r\nvar EntityManagerExports = require('./EntityManager');\r\nvar EntityManager = EntityManagerExports.EntityManager;\r\nvar GLOBAL_EntityManager = EntityManagerExports.GLOBAL_EntityManager;\r\n\r\nvar TransformationsExports = require('./Transformations');\r\nvar Transformations = TransformationsExports.Transformations;\r\n\r\nvar MessageDispatcherExports = require('./MessageDispatcher');\r\nvar MessageDispatcher = MessageDispatcherExports.MessageDispatcher;\r\nvar SEND_MSG_IMMEDIATELY = MessageDispatcherExports.SEND_MSG_IMMEDIATELY;\r\nvar NO_ADDITIONAL_INFO = MessageDispatcherExports.NO_ADDITIONAL_INFO;\r\nvar SENDER_ID_IRRELEVANT = MessageDispatcherExports.SENDER_ID_IRRELEVANT;\r\nvar GLOBAL_MessageDispatcher = MessageDispatcherExports.GLOBAL_MessageDispatcher;\r\n\r\nvar SoccerMessagesExports = require('./SoccerMessages');\r\nvar SoccerMessages = SoccerMessagesExports.SoccerMessages;\r\nvar MessageType = SoccerMessagesExports.MessageType;\r\n\r\nvar Params = require('./Params');\r\n\r\nclass SoccerTeam\r\n{\r\n\tconstructor(game, home_goal, opponents_goal, pitch, color)\r\n\t{\r\n\t\tthis.m_pOpponentsGoal = opponents_goal;\r\n\t\tthis.m_pHomeGoal = home_goal;\r\n\t\tthis.m_pOpponents = null;\r\n\t\tthis.m_pPitch = pitch;\r\n\t\tthis.m_Color = color;\r\n\t\tthis.m_dDistSqToBallOfClosestPlayer = 0.0;\r\n\t\tthis.m_pSupportingPlayer = null;\r\n\t\tthis.m_pReceivingPlayer = null;\r\n\t\tthis.m_pControllingPlayer = null;\r\n\t\tthis.m_pPlayerClosestToBall = null;\r\n\t\tthis.m_Players = [];\r\n\t\t\t\t\t\t\t\t\t\t   \r\n\t\t//setup the state machine\r\n\t\tthis.m_pStateMachine = new StateMachine(this);\r\n\r\n\t\tthis.m_pStateMachine.SetCurrentState(new Defending);\r\n\t\tthis.m_pStateMachine.SetPreviousState(new Defending);\r\n\t\tthis.m_pStateMachine.SetGlobalState(null);\r\n\r\n\t\t//create the players and goalkeeper\r\n\t\tthis.CreatePlayers(game);\r\n\t  \r\n\t\tfor (var i = 0; i < this.m_Players.length; i ++)\r\n\t\t{\r\n\t\t\tthis.m_Players[i].Steering().SeparationOn();   \r\n\t\t}\r\n\r\n\t\t//create the sweet spot calculator\r\n\t\tthis.m_pSupportSpotCalc = new SupportSpotCalculator(Params.NumSupportSpotsX,\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t Params.NumSupportSpotsY,\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t this);\r\n\t}\r\n\t\r\n\tGetSupportSpot(){return this.m_pSupportSpotCalc.GetBestSupportingSpot();}\r\n\t\r\n\tID(){return this.m_Color;}\r\n  \r\n\t\r\nGetFSM(){return this.m_pStateMachine;}\r\nUpdate(game)\r\n{\r\n  //this information is used frequently so it's more efficient to \r\n  //calculate it just once each frame\r\n  this.CalculateClosestPlayerToBall();\r\n\r\n  //the team state machine switches between attack/defense behavior. It\r\n  //also handles the 'kick off' state where a team must return to their\r\n  //kick off positions before the whistle is blown\r\n  \r\n  this.m_pStateMachine.Update();\r\n\r\n\tfor (var i = 0; i < this.m_Players.length; i ++)\r\n\t{\r\n\t\tthis.m_Players[i].Update(game);   \r\n\t}\r\n\t\t\r\n\r\n}\r\n\r\nDetermineBestSupportingAttacker()\r\n{\r\n  var ClosestSoFar = Number.MAX_VALUE;\r\n\r\n  var BestPlayer = null;\r\n\r\n  for (var i = 0; i < this.m_Players.length; i ++)\r\n\t{\r\n    //only attackers utilize the BestSupportingSpot\r\n    if ( (this.m_Players[i].Role() == PlayerBaseEnum.ATTACKER) && (this.m_Players[i] != this.m_pControllingPlayer) )\r\n    {\r\n      //calculate the dist. Use the squared value to avoid sqrt\r\n\t  var dist = this.m_Players[i].Pos().distance(this.m_pSupportSpotCalc.GetBestSupportingSpot());\r\n    \r\n      //if the distance is the closest so far and the player is not a\r\n      //goalkeeper and the player is not the one currently controlling\r\n      //the ball, keep a record of this player\r\n      if ((dist < Math.sqrt(ClosestSoFar)) )\r\n      {\r\n        ClosestSoFar = dist;\r\n\r\n        BestPlayer = this.m_Players[i];\r\n      }\r\n    }\r\n  }\r\n\r\n  return BestPlayer;\r\n}\r\n\r\n\r\n\tOpponents()\r\n\t{\r\n\t\treturn this.m_pOpponents;\r\n\t}\r\n\t\r\n\tSetOpponents(opps)\r\n\t{\r\n\t\tthis.m_pOpponents = opps;\r\n\t}\r\n\t\r\n\tColor()\r\n\t{\r\n\t\treturn this.m_Color;\r\n\t}\r\n\t\r\n\tPitch()\r\n\t{\r\n\t\treturn this.m_pPitch;\r\n\t}\r\n\t\r\n\tHomeGoal()\r\n\t{\r\n\t\treturn this.m_pHomeGoal;\r\n\t}\r\n\t\r\n\tOpponentsGoal()\r\n\t{\r\n\t\treturn this.m_pOpponentsGoal;\r\n\t}\r\n\tClosestDistToBallSq()\r\n\t{\r\n\t\treturn this.m_dDistSqToBallOfClosestPlayer;\r\n\t}\r\n\t\r\n\tCalculateClosestPlayerToBall()\r\n\t{\r\n\t\tvar ClosestSoFar = Number.MAX_VALUE;\r\n\r\n\t\tfor(var p = 0; p < this.m_Players.length; p ++)\r\n\t\t{\r\n\t\t\tvar dist = this.m_Players[p].Pos().distance(this.Pitch().Ball().Pos()) * this.m_Players[p].Pos().distance(this.Pitch().Ball().Pos());\r\n\t\t\tthis.m_Players[p].SetDistSqToBall(dist);\r\n\t\t\t\r\n\t\t\tif (dist < ClosestSoFar)\r\n\t\t\t{\r\n\t\t\t\tClosestSoFar = dist;\r\n\r\n\t\t\t\tthis.m_pPlayerClosestToBall = this.m_Players[p];\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tthis.m_dDistSqToBallOfClosestPlayer = ClosestSoFar;\r\n\t}\r\n\t\r\n\tSetPlayerClosestToBall(plyr){this.m_pPlayerClosestToBall=plyr;}\r\n\t\r\n\tPlayerClosestToBall()\r\n\t{\r\n\t\treturn this.m_pPlayerClosestToBall;\r\n\t}\r\n\t\r\n\tControllingPlayer()\r\n\t{\r\n\t\treturn this.m_pControllingPlayer;\r\n\t}\r\n\t\r\n\tSetControllingPlayer(plyr)\r\n\t{\r\n\t\tthis.m_pControllingPlayer = plyr;\r\n\t\t\r\n\t\t//rub it in the opponents faces!\r\n\t\tthis.Opponents().LostControl();\r\n\t}\r\n\r\n\tLostControl()\r\n\t{\r\n\t\tthis.m_pControllingPlayer = null;\r\n\t}\r\n\t\r\n\r\n\t//  sends a message to all players to return to their home areas forthwith\r\n\tReturnAllFieldPlayersToHome()\r\n\t{\r\n\t\tfor(var p = 0; p < this.m_Players.length; p ++)\r\n\t\t{\r\n\t\t\tif (this.m_Players[p].Role() != PlayerBaseEnum.GOALKEEPER)\r\n\t\t\t{\r\n\t\t\t\tGLOBAL_MessageDispatcher.DispatchMsg(\r\n\t\t\t\t\t\t\tSEND_MSG_IMMEDIATELY,\r\n                            1,\r\n                            this.m_Players[p].ID(),\r\n                            MessageType.Msg_GoHome,\r\n                            null);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n\tSetReceiver(plyr){this.m_pReceivingPlayer = plyr;}\r\n  \r\n\tReceiver()\r\n\t{\r\n\t\treturn this.m_pReceivingPlayer;\r\n\t}\r\n\t\r\n\tMembers()\r\n\t{\r\n\t\treturn this.m_Players;\r\n\t}  \r\n  \r\n\tFindPass(passer, power, MinPassingDistance)\r\n\t{  \r\n\t\tvar ClosestToGoalSoFar = Number.MAX_VALUE;\r\n\t\tvar Target;\r\n\t\tvar receiver = null;\r\n\t\tvar PassTarget = null;\r\n\t\tvar ret;\r\n\r\n\t\t//iterate through all this player's team members and calculate which\r\n\t\t//one is in a position to be passed the ball \r\n\t\tfor(var p = 0; p < this.m_Players.length; p ++)\r\n\t\t{\r\n\t\t\t//make sure the potential receiver being examined is not this player\r\n\t\t\t//and that it is further away than the minimum pass distance\r\n\t\t\tif ( (this.m_Players[p] != passer) && (passer.Pos().distance(this.m_Players[p].Pos()) > MinPassingDistance))                  \r\n\t\t\t{          \r\n\t\t\t\tret = this.GetBestPassToReceiver(passer, this.m_Players[p], power);\r\n\t\t\t\tif (ret[0])\r\n\t\t\t\t{\r\n\t\t\t\t\tTarget = ret[1];\r\n\t\t\t\t\t//if the pass target is the closest to the opponent's goal line found\r\n\t\t\t\t\t// so far, keep a record of it\r\n\t\t\t\t\tvar Dist2Goal = Math.abs(Target.x - this.OpponentsGoal().Center().x);\r\n\r\n\t\t\t\t\tif (Dist2Goal < ClosestToGoalSoFar)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tClosestToGoalSoFar = Dist2Goal;\r\n          \r\n\t\t\t\t\t\t//keep a record of this player\r\n\t\t\t\t\t\treceiver = this.m_Players[p];\r\n\r\n\t\t\t\t\t\t//and the target\r\n\t\t\t\t\t\tPassTarget = Target;\r\n\t\t\t\t\t}     \r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}//next team member\r\n\r\n\t\tif (receiver != null) return [true, receiver, PassTarget];\r\n \r\n\t\telse return [false, null, null];\r\n\t}\r\n\r\nGetTangentPoints (C, R, P)\r\n{\r\n  var T1 = new Phaser.Point(0, 0);\r\n  var T2 = new Phaser.Point(0, 0);\r\n  \r\n  var PmC = new Phaser.Point(P.x - C.x, P.y - C.y);\r\n  var SqrLen = PmC.getMagnitudeSq();\r\n  var RSqr = R*R;\r\n  if ( SqrLen <= RSqr )\r\n  {\r\n      // P is inside or on the circle\r\n      return [false, T1, T2];\r\n  }\r\n\r\n  var InvSqrLen = 1/SqrLen;\r\n  var Root = Math.sqrt(Math.abs(SqrLen - RSqr));\r\n  \r\n  T1.x = C.x + R*(R*PmC.x - PmC.y*Root)*InvSqrLen;\r\n  T1.y = C.y + R*(R*PmC.y + PmC.x*Root)*InvSqrLen;\r\n  T2.x = C.x + R*(R*PmC.x + PmC.y*Root)*InvSqrLen;\r\n  T2.y = C.y + R*(R*PmC.y - PmC.x*Root)*InvSqrLen;\r\n\r\n  return [true, T1, T2];\r\n}\r\n\t//---------------------- GetBestPassToReceiver ---------------------------\r\n\t//\r\n\t//  Three potential passes are calculated. One directly toward the receiver's\r\n\t//  current position and two that are the tangents from the ball position\r\n\t//  to the circle of radius 'range' from the receiver.\r\n\t//  These passes are then tested to see if they can be intercepted by an\r\n\t//  opponent and to make sure they terminate within the playing area. If\r\n\t//  all the passes are invalidated the function returns false. Otherwise\r\n\t//  the function returns the pass that takes the ball closest to the \r\n\t//  opponent's goal area.\r\n\t//------------------------------------------------------------------------\r\n\tGetBestPassToReceiver(passer, receiver, power)\r\n\t{  \r\n\t\t//first, calculate how much time it will take for the ball to reach \r\n\t\t//this receiver, if the receiver was to remain motionless \r\n\t\tvar time = this.Pitch().Ball().TimeToCoverDistance(this.Pitch().Ball().Pos(),\r\n                                                    receiver.Pos(),\r\n                                                    power);\r\n\r\n\t\t//return false if ball cannot reach the receiver after having been\r\n\t\t//kicked with the given power\r\n\t\tif (time < 0) return false;\r\n\r\n\t\t//the maximum distance the receiver can cover in this time\r\n\t\tvar InterceptRange = time * receiver.MaxSpeed();\r\n  \r\n\t\t//Scale the intercept range\r\n\t\tvar ScalingFactor = 0.3;\r\n\t\tInterceptRange *= ScalingFactor;\r\n\r\n\t\t//now calculate the pass targets which are positioned at the intercepts\r\n\t\t//of the tangents from the ball to the receiver's range circle.\r\n\t\tvar ret = this.GetTangentPoints(receiver.Pos(),\r\n                   InterceptRange,\r\n                   this.Pitch().Ball().Pos());\r\n\t\t\t\t   \r\n\t\tvar ip1 = ret[1];\r\n\t\tvar ip2 = ret[2];\r\n \r\n\t\tvar NumPassesToTry = 3;\r\n\t\tvar Passes = [ip1, receiver.Pos(), ip2];\r\n  \r\n  \r\n\t\t// this pass is the best found so far if it is:\r\n\t\t//\r\n\t\t//  1. Further upfield than the closest valid pass for this receiver\r\n\t\t//     found so far\r\n\t\t//  2. Within the playing area\r\n\t\t//  3. Cannot be intercepted by any opponents\r\n\r\n\t\tvar ClosestSoFar =  Number.MAX_VALUE;\r\n\t\tvar  bResult      = false;\r\n\t\tvar  PassTarget      = null;\r\n\r\n\t\tfor (var pass = 0; pass < NumPassesToTry; ++pass)\r\n\t\t{    \r\n\t\t\tvar dist = Math.abs(Passes[pass].x - this.OpponentsGoal().Center().x);\r\n\r\n\t\t\tif (( dist < ClosestSoFar) &&\r\n\t\t\t\tthis.Pitch().PlayingArea().Inside(Passes[pass]) &&\r\n\t\t\t\t\tthis.isPassSafeFromAllOpponents(this.Pitch().Ball().Pos(),\r\n                                   Passes[pass],\r\n                                   receiver,\r\n                                   power))\r\n        \r\n\t\t\t{\r\n\t\t\t\tClosestSoFar = dist;\r\n\t\t\t\tPassTarget   = Passes[pass];\r\n\t\t\t\tbResult      = true;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn [bResult, PassTarget];\r\n\t}\r\n\t\r\n\tDetermineBestSupportingPosition()\r\n\t{\r\n\t\tthis.m_pSupportSpotCalc.DetermineBestSupportingPosition();\r\n\t}\r\n  \r\n\r\n\t//----------------------- isPassSafeFromOpponent -------------------------\r\n\t//\r\n\t//  test if a pass from 'from' to 'to' can be intercepted by an opposing\r\n\t//  player\r\n\t//------------------------------------------------------------------------\r\n\t\r\n\t// from : controllingplayer.pos()\r\n\t// target : requester.pos()\r\n\t// receiver : requester\r\n\tisPassSafeFromOpponent(from, target, receiver, opp, PassingForce)\r\n\t{\r\n\t\tvar ToTarget = new Phaser.Point(target.x - from.x, target.y - from.y);\r\n\t\tvar ToTargetNormalized = new Phaser.Point(ToTarget.x, ToTarget.y).normalize();\r\n\t\t\r\n\t\tvar LocalPosOpp = Transformations.PointToLocalSpace(opp.Pos(),\r\n                                         ToTargetNormalized,\r\n                                         new Phaser.Point(ToTargetNormalized.x, ToTargetNormalized.y).perp(),\r\n                                         from);\r\n\t\t\r\n\t\t//if opponent is behind the kicker then pass is considered okay(this is \r\n\t\t//based on the assumption that the ball is going to be kicked with a \r\n\t\t//velocity greater than the opponent's max velocity)\r\n\t\tif ( LocalPosOpp.x < 0 )\r\n\t\t{     \r\n\t\t\treturn true;\r\n\t\t}\r\n  \r\n\t\t//if the opponent is further away than the target we need to consider if\r\n\t\t//the opponent can reach the position before the receiver.\r\n\t\tif (from.distance(target) < opp.Pos().distance(from))\r\n\t\t{\r\n\t\t\tif (receiver != null)\r\n\t\t\t{\r\n\t\t\t\tif ( target.distance(opp.Pos())  > target.distance(receiver.Pos()) )\r\n\t\t\t\t{\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t}\r\n\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\treturn true;\r\n\t\t\t} \r\n\t\t}\r\n  \r\n\t\t//calculate how long it takes the ball to cover the distance to the \r\n\t\t//position orthogonal to the opponents position\r\n\t\tvar TimeForBall = this.Pitch().Ball().TimeToCoverDistance(new Phaser.Point(0,0),\r\n                                       new Phaser.Point(LocalPosOpp.x, 0),\r\n                                       PassingForce);\r\n\r\n\t\t//now calculate how far the opponent can run in this time\r\n\t\tvar reach = opp.MaxSpeed() * TimeForBall +\r\n                this.Pitch().Ball().BRadius()+\r\n                opp.BRadius();\r\n\t\t\r\n\t\t//if the distance to the opponent's y position is less than his running\r\n\t\t//range plus the radius of the ball and the opponents radius then the\r\n\t\t//ball can be intercepted\r\n\t\tif ( Math.abs(LocalPosOpp.y) < reach )\r\n\t\t{\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\treturn true;\r\n\t}\r\n\r\n\t//---------------------- isPassSafeFromAllOpponents ----------------------\r\n\t//\r\n\t//  tests a pass from position 'from' to position 'target' against each member\r\n\t//  of the opposing team. Returns true if the pass can be made without\r\n\t//  getting intercepted\r\n\t//------------------------------------------------------------------------\r\n\t// from : controllingplayer.pos()\r\n\t// target : requester.pos()\r\n\t// receiver : requester\r\n\tisPassSafeFromAllOpponents(from, target, receiver, PassingForce)\r\n\t{\r\n\t\tvar oppmembers = this.Opponents().Members();\r\n\t\t\t\t\r\n\t\tfor(var p = 0; p < oppmembers.length; p ++)\r\n\t\t{\r\n\t\t\tif (!this.isPassSafeFromOpponent(from, target, receiver, oppmembers[p], PassingForce))\r\n\t\t\t{\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn true;\r\n\t}\r\n\t\r\nCanShoot(BallPos, power)\r\n{\r\n  //the number of randomly created shot targets this method will test \r\n  var NumAttempts = Params.NumAttemptsToFindValidStrike;\r\n\r\n  while (NumAttempts--)\r\n  {\r\n    //choose a random position along the opponent's goal mouth. (making\r\n    //sure the ball's radius is taken into account)\r\n    var ShotTarget = this.OpponentsGoal().Center();\r\n\r\n    //the y value of the shot position should lay somewhere between two\r\n    //goalposts (taking into consideration the ball diameter)\r\n    var MinYVal = (this.OpponentsGoal().LeftPost().y + this.Pitch().Ball().BRadius());\r\n    var MaxYVal = (this.OpponentsGoal().RightPost().y - this.Pitch().Ball().BRadius());\r\n\t\t\t\r\n    ShotTarget.y = Math.random() * (MaxYVal - MinYVal) + MinYVal;\r\n\t\t\r\n    //make sure striking the ball with the given power is enough to drive\r\n    //the ball over the goal line.\r\n    var time = this.Pitch().Ball().TimeToCoverDistance(BallPos,\r\n                                                      ShotTarget,\r\n                                                      power);\r\n    \r\n    //if it is, this shot is then tested to see if any of the opponents\r\n    //can intercept it.\r\n    if (time >= 0)\r\n    {\r\n      if (this.isPassSafeFromAllOpponents(BallPos, ShotTarget, null, power))\r\n      {\r\n        return [true, ShotTarget];\r\n      }\r\n    }\r\n  }\r\n  \r\n  return [false, ShotTarget];\r\n}\r\n\r\n\r\n\tCreatePlayers(game)\r\n\t{\r\n\t\tif (this.m_Color == ColorTeam.BLUE)\r\n\t\t{\r\n\t\t\tthis.m_Players.push(new Goalkeeper(game, this, 1, new TendGoal, new Phaser.Point(0,1), new Phaser.Point(0.0, 0.0), Params.PlayerMass, Params.PlayerMaxForce, Params.PlayerMaxSpeedWithoutBall, Params.PlayerMaxTurnRate, Params.PlayerScale, PlayerBaseEnum.GOALKEEPER));\r\n\t\t\t\r\n\t\t\tthis.m_Players.push(new FieldPlayer(game, this, 6, new Wait, new Phaser.Point(0,1), new Phaser.Point(0.0, 0.0), Params.PlayerMass, Params.PlayerMaxForce, Params.PlayerMaxSpeedWithoutBall, Params.PlayerMaxTurnRate, Params.PlayerScale, PlayerBaseEnum.ATTACKER));\r\n\t\t\t\r\n\t\t\tthis.m_Players.push(new FieldPlayer(game, this, 8, new Wait, new Phaser.Point(0,1), new Phaser.Point(0.0, 0.0), Params.PlayerMass, Params.PlayerMaxForce, Params.PlayerMaxSpeedWithoutBall, Params.PlayerMaxTurnRate, Params.PlayerScale, PlayerBaseEnum.ATTACKER));\r\n\t\t\t\r\n\t\t\tthis.m_Players.push(new FieldPlayer(game, this, 3, new Wait, new Phaser.Point(0,1), new Phaser.Point(0.0, 0.0), Params.PlayerMass, Params.PlayerMaxForce, Params.PlayerMaxSpeedWithoutBall, Params.PlayerMaxTurnRate, Params.PlayerScale, PlayerBaseEnum.DEFENDER));\r\n\t\t\t\r\n\t\t\tthis.m_Players.push(new FieldPlayer(game, this, 5, new Wait, new Phaser.Point(0,1), new Phaser.Point(0.0, 0.0), Params.PlayerMass, Params.PlayerMaxForce, Params.PlayerMaxSpeedWithoutBall, Params.PlayerMaxTurnRate, Params.PlayerScale, PlayerBaseEnum.DEFENDER));\r\n\t\t\t\r\n\t\t\t\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tthis.m_Players.push(new Goalkeeper(game, this, 16, new TendGoal, new Phaser.Point(0,-1), new Phaser.Point(0.0, 0.0), Params.PlayerMass, Params.PlayerMaxForce, Params.PlayerMaxSpeedWithoutBall, Params.PlayerMaxTurnRate, Params.PlayerScale, PlayerBaseEnum.GOALKEEPER));\r\n\t\t\t\r\n\t\t\tthis.m_Players.push(new FieldPlayer(game, this, 9, new Wait, new Phaser.Point(0,-1), new Phaser.Point(0.0, 0.0), Params.PlayerMass, Params.PlayerMaxForce, Params.PlayerMaxSpeedWithoutBall, Params.PlayerMaxTurnRate, Params.PlayerScale, PlayerBaseEnum.ATTACKER));\r\n\t\t\t\r\n\t\t\tthis.m_Players.push(new FieldPlayer(game, this, 11, new Wait, new Phaser.Point(0,-1), new Phaser.Point(0.0, 0.0), Params.PlayerMass, Params.PlayerMaxForce, Params.PlayerMaxSpeedWithoutBall, Params.PlayerMaxTurnRate, Params.PlayerScale, PlayerBaseEnum.ATTACKER));\r\n\t\t\t\r\n\t\t\tthis.m_Players.push(new FieldPlayer(game, this, 12, new Wait, new Phaser.Point(0,-1), new Phaser.Point(0.0, 0.0), Params.PlayerMass, Params.PlayerMaxForce, Params.PlayerMaxSpeedWithoutBall, Params.PlayerMaxTurnRate, Params.PlayerScale, PlayerBaseEnum.DEFENDER));\r\n\t\t\t\r\n\t\t\tthis.m_Players.push(new FieldPlayer(game, this, 14, new Wait, new Phaser.Point(0,-1), new Phaser.Point(0.0, 0.0), Params.PlayerMass, Params.PlayerMaxForce, Params.PlayerMaxSpeedWithoutBall, Params.PlayerMaxTurnRate, Params.PlayerScale, PlayerBaseEnum.DEFENDER));\r\n\t\t\r\n\t\t}\r\n\r\n\t\tfor(var p = 0; p < this.m_Players.length; p ++)\r\n\t\t{\r\n\t\t\tGLOBAL_EntityManager.RegisterEntity(this.m_Players[p]);\r\n\t\t}\r\n\t}\r\n\t\r\n\r\nGetPlayerFromID(id)\r\n{\r\n\t\tfor(var p = 0; p < this.m_Players.length; p ++)\r\n\t\t{\r\n\t\t\tif (this.m_Players[p].ID() == id) return this.m_Players[p];\r\n\t\t}\r\n\r\n  return null;\r\n}\r\n\r\nSetPlayerHomeRegion(plyr, region)\r\n{\r\n\tif (typeof this.m_Players[plyr] !== 'undefined')\r\n\t\tthis.m_Players[plyr].SetHomeRegion(region);\r\n}\r\n\r\nUpdateTargetsOfWaitingPlayers()\r\n{\r\n\t\tfor(var p = 0; p < this.m_Players.length; p ++)\r\n\t\t{\r\n    if ( this.m_Players[p].Role() != PlayerBaseEnum.GOALKEEPER )\r\n    {\r\n      //cast to a field player\r\n      var plyr = this.m_Players[p];\r\n      \r\n      if ( plyr.GetFSM().isInState(new Wait()) ||\r\n           plyr.GetFSM().isInState(new ReturnToHomeRegion()) )\r\n      {\r\n        plyr.Steering().SetTarget(plyr.HomeRegion().Center());\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nAllPlayersAtHome()\r\n{\r\n\tconsole.log(\"AllPlayersAtHome\");\r\n\t\tfor(var p = 0; p < this.m_Players.length; p ++)\r\n\t\t{\r\n\tconsole.log(\"AllPlayersAtHome p = '\"+p+\"'\");\r\n\tconsole.log(\"AllPlayersAtHome InHomeRegion = '\"+this.m_Players[p].InHomeRegion()+\"'\");\r\n\tconsole.dir(this.m_Players[p]);\r\n    if (this.m_Players[p].InHomeRegion() == false)\r\n    {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  return true;\r\n}\r\n\r\nRequestPass(requester)\r\n{\r\n  //maybe put a restriction here\r\n  if (Math.random() > 0.1) return;\r\n  \r\n  if (this.isPassSafeFromAllOpponents(this.ControllingPlayer().Pos(),\r\n                                 requester.Pos(),\r\n                                 requester,\r\n                                 Params.MaxPassingForce))\r\n  {\r\n\r\n    //tell the player to make the pass\r\n    //let the receiver know a pass is coming \r\n\t\r\n    GLOBAL_MessageDispatcher.DispatchMsg(SEND_MSG_IMMEDIATELY,\r\n                          requester.ID(),\r\n                          this.ControllingPlayer().ID(),\r\n                          MessageType.Msg_PassToMe,\r\n                          requester); \r\n\r\n  }\r\n}\r\n\r\n\r\nisOpponentWithinRadius(pos, rad)\r\n{\r\n\tvar Opps = this.Opponents().Members();\r\n\tvar dist;\r\n\tfor(var p = 0; p < Opps.length; p ++)\r\n\t{\r\n\t\tdist = pos.distance(Opps[p].Pos()) * pos.distance(Opps[p].Pos());\r\n\t\tif (dist < rad*rad)\r\n\t\t{\r\n\t\t  return true;\r\n\t\t}\r\n\t }\r\n\r\n\treturn false;\r\n}\r\n\r\n\tInControl()\r\n\t{\r\n\t\tif(this.m_pControllingPlayer != null)\r\n\t\t{\r\n\t\t\treturn true; \r\n\t\t}\r\n\t\telse \r\n\t\t{\r\n\t\t\treturn false;\r\n\t\t}\r\n\t}\r\n\t\r\n\t\r\n\tSupportingPlayer()\r\n\t{\r\n\t\treturn this.m_pSupportingPlayer;\r\n\t}\r\n\r\n\tSetSupportingPlayer(plyr)\r\n\t{\r\n\t\tthis.m_pSupportingPlayer = plyr;\r\n\t}\r\n  \r\n\r\n\tRender(game)\r\n\t{\r\n\t\tfor(var p = 0; p < this.m_Players.length; p ++)\r\n\t\t{\r\n\t\t\tthis.m_Players[p].Render(game);\r\n\t\t}\r\n\t\t/*\r\n  std::vector<PlayerBase*>::const_iterator it = m_Players.begin();\r\n\r\n  for (it; it != m_Players.end(); ++it)\r\n  {\r\n    (*it)->Render();\r\n  }\r\n\r\n  //show the controlling team and player at the top of the display\r\n  if (Prm.bShowControllingTeam)\r\n  {\r\n    gdi->TextColor(Cgdi::white);\r\n    \r\n    if ( (Color() == blue) && InControl())\r\n    {\r\n      gdi->TextAtPos(20,3,\"Blue in Control\");\r\n    }\r\n    else if ( (Color() == red) && InControl())\r\n    {\r\n      gdi->TextAtPos(20,3,\"Red in Control\");\r\n    }\r\n    if (m_pControllingPlayer != NULL)\r\n    {\r\n      gdi->TextAtPos(Pitch()->cxClient()-150, 3, \"Controlling Player: \" + ttos(m_pControllingPlayer->ID()));\r\n    }\r\n  }\r\n\r\n  //render the sweet spots\r\n  if (Prm.bSupportSpots && InControl())\r\n  {\r\n    m_pSupportSpotCalc->Render();\r\n  }\r\n\r\n//#define SHOW_TEAM_STATE\r\n#ifdef SHOW_TEAM_STATE\r\n  if (Color() == red)\r\n  {\r\n    gdi->TextColor(Cgdi::white);\r\n\r\n    if (CurrentState() == Attacking::Instance())\r\n    {\r\n      gdi->TextAtPos(160, 20, \"Attacking\");\r\n    }\r\n    if (CurrentState() == Defending::Instance())\r\n    {\r\n      gdi->TextAtPos(160, 20, \"Defending\");\r\n    }\r\n    if (CurrentState() == PrepareForKickOff::Instance())\r\n    {\r\n      gdi->TextAtPos(160, 20, \"Kickoff\");\r\n    }\r\n  }\r\n  else\r\n  {\r\n    if (CurrentState() == Attacking::Instance())\r\n    {\r\n      gdi->TextAtPos(160, Pitch()->cyClient()-40, \"Attacking\");\r\n    }\r\n    if (CurrentState() == Defending::Instance())\r\n    {\r\n      gdi->TextAtPos(160, Pitch()->cyClient()-40, \"Defending\");\r\n    }\r\n    if (CurrentState() == PrepareForKickOff::Instance())\r\n    {\r\n      gdi->TextAtPos(160, Pitch()->cyClient()-40, \"Kickoff\");\r\n    }\r\n  }\r\n#endif\r\n\r\n//#define SHOW_SUPPORTING_PLAYERS_TARGET\r\n#ifdef SHOW_SUPPORTING_PLAYERS_TARGET\r\n  if (m_pSupportingPlayer)\r\n  {\r\n    gdi->BlueBrush();\r\n    gdi->RedPen();\r\n    gdi->Circle(m_pSupportingPlayer->Steering()->Target(), 4);\r\n\r\n  }\r\n#endif\r\n\r\n}\r\n*/\r\n\t}\r\n}\r\n\r\nmodule.exports.SoccerTeam = SoccerTeam;\t\r\n\r\n","'use strict';\r\n\r\nclass State\r\n{\r\n  constructor(name)\r\n  {\r\n    this.NameOfEntity = name;\r\n  }\r\n\r\n  GetNameOfEntity()\r\n  {\r\n    return this.NameOfEntity;\r\n  }\r\n}\r\n\r\nmodule.exports.State = State;\r\n\r\n","'use strict';\r\n\r\nclass StateMachine\r\n{\r\n  constructor(owner)\r\n  {\r\n    this.m_pOwner = owner;\r\n    this.m_pCurrentState = null;\r\n    this.m_pPreviousState = null;\r\n    this.m_pGlobalState = null;\r\n  }\r\n\r\n  SetCurrentState(s)\r\n  {\r\n    this.m_pCurrentState = s;\r\n  }\r\n\r\n  SetGlobalState(s)\r\n  {\r\n    this.m_pGlobalState = s;\r\n  }\r\n\r\n  SetPreviousState(s)\r\n  {\r\n    this.m_pPreviousState = s;\r\n  }\r\n\r\n  HandleMessage(msg)\r\n  {\r\n    //first see if the current state is valid and that it can handle\r\n    //the message\r\n    if (this.m_pCurrentState && this.m_pCurrentState.OnMessage(this.m_pOwner, msg))\r\n    {\r\n      return true;\r\n    }\r\n\r\n    //if not, and if a global state has been implemented, send\r\n    //the message to the global state\r\n    if (this.m_pGlobalState && this.m_pGlobalState.OnMessage(this.m_pOwner, msg))\r\n    {\r\n      return true;\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n  Update()\r\n  {\r\n    if (this.m_pGlobalState)\r\n    {\r\n      this.m_pGlobalState.Execute(this.m_pOwner);\r\n    }\r\n\r\n    if (this.m_pCurrentState)\r\n    {\r\n      this.m_pCurrentState.Execute(this.m_pOwner);\r\n    }\r\n  }\r\n\r\n  ChangeState(pNewState)\r\n  {\r\n    //keep a record of the previous state\r\n    this.m_pPreviousState = this.m_pCurrentState;\r\n    //call the exit method of the existing state\r\n    this.m_pCurrentState.Exit(this.m_pOwner);\r\n    //change state to the new state\r\n    this.m_pCurrentState = pNewState;\r\n    //call the entry method of the new state\r\n    this.m_pCurrentState.Enter(this.m_pOwner);\r\n  }\r\n\r\n  //change state back to the previous state\r\n  RevertToPreviousState()\r\n  {\r\n    this.ChangeState(this.m_pPreviousState);\r\n  }\r\n\r\n  CurrentState()\r\n  {\r\n    return this.m_pCurrentState;\r\n  }\r\n\r\n  GlobalState()\r\n  {\r\n    return this.m_pGlobalState;\r\n  }\r\n\r\n  PreviousState()\r\n  {\r\n    return this.m_pPreviousState;\r\n  }\r\n\r\n  //returns true if the current states type is equal to the type of the //class passed as a parameter.\r\n  isInState(st)\r\n  {\r\n    if (this.m_pCurrentState.GetNameOfEntity() === st.GetNameOfEntity())\r\n     return true;\r\n\r\n    return false;\r\n  }\r\n\r\n  GetNameOfCurrentState()\r\n  {\r\n    return this.m_pCurrentState.name();\r\n  }\r\n}\r\n\r\nmodule.exports.StateMachine = StateMachine;\r\n","'use strict';\r\n\r\nvar Params = require('./Params');\r\n\r\nvar TransformationsExports = require('./Transformations');\r\nvar Transformations = TransformationsExports.Transformations;\r\n\r\nvar AutoListExports = require('./AutoList');\r\nvar ListMembers = AutoListExports.AutoList;\r\n\r\nvar behavior_type = {\r\n    none: 0x0000,\r\n    seek: 0x0001,\r\n    arrive: 0x0002,\r\n    separation: 0x0004,\r\n    pursuit: 0x0008,\r\n    interpose: 0x0010,\r\n  };\r\n\r\nvar Deceleration = {\r\n    slow: 3,\r\n    normal: 2,\r\n    fast: 1,\r\n  };\r\n\r\nclass SteeringBehaviors\r\n{\r\n  // hometeam type SoccerTeam\r\n  constructor(agent, world, ball)\r\n  {\r\n    this.m_pPlayer = agent;\r\n    this.m_iFlags = 0;\r\n    this.m_dMultSeparation = Params.SeparationCoefficient;\r\n    this.m_bTagged = false;\r\n    this.m_dViewDistance = Params.ViewDistance;\r\n    this.m_pBall = ball;\r\n    this.m_dInterposeDist = 0.0;\r\n    this.m_Antenna = new Phaser.Point(5, 0);\r\n\r\n    this.m_vSteeringForce = new Phaser.Point(0, 0);\r\n  }\r\n\r\n  AccumulateForce(sf, ForceToAdd)\r\n  {\r\n    //first calculate how much steering force we have left to use\r\n    var MagnitudeSoFar = sf.getMagnitude();\r\n\r\n    var magnitudeRemaining = this.m_pPlayer.MaxForce() - MagnitudeSoFar;\r\n\r\n    //return false if there is no more force left to use\r\n    if (magnitudeRemaining <= 0.0)\r\n     return false;\r\n\r\n    //calculate the magnitude of the force we want to add\r\n    var MagnitudeToAdd = ForceToAdd.getMagnitude();\r\n\r\n    //now calculate how much of the force we can really add\r\n    if (MagnitudeToAdd > magnitudeRemaining)\r\n    {\r\n      MagnitudeToAdd = magnitudeRemaining;\r\n    }\r\n\r\n    //add it to the steering force\r\n    var temp = new Phaser.Point(ForceToAdd.x, ForceToAdd.y).normalize();\r\n    sf.add(temp.x * MagnitudeToAdd, temp.y * MagnitudeToAdd);\r\n\r\n    return true;\r\n  }\r\n\r\n  Calculate()\r\n  {\r\n    //reset the force\r\n    this.m_vSteeringForce.set(0, 0);\r\n\r\n    //this will hold the value of each individual steering force\r\n    this.m_vSteeringForce = this.SumForces();\r\n\r\n    //make sure the force doesn't exceed the vehicles maximum allowable\r\n    //this.m_vSteeringForce.Truncate(this.m_pPlayer.MaxForce());\r\n\r\n    //console.log(\"Calculate m_vSteeringForce\\n\");\r\n    Transformations.Truncate(this.m_vSteeringForce, this.m_pPlayer.MaxForce());\r\n\r\n    return new Phaser.Point(this.m_vSteeringForce.x, this.m_vSteeringForce.y);\r\n  }\r\n\r\n  SumForces()\r\n  {\r\n    var force = new Phaser.Point(0, 0);\r\n\r\n    this.FindNeighbours();\r\n\r\n    if (this.On(behavior_type.separation))\r\n    {\r\n      var separation = this.Separation();\r\n      var tmpx = separation.x * this.m_dMultSeparation;\r\n      var tmpy = separation.y * this.m_dMultSeparation;\r\n\r\n      force.add(tmpx, tmpy);\r\n\r\n      if (!this.AccumulateForce(this.m_vSteeringForce, force))\r\n       return new Phaser.Point(this.m_vSteeringForce.x, this.m_vSteeringForce.y);\r\n    }\r\n\r\n    if (this.On(behavior_type.seek))\r\n    {\r\n      var seek = this.Seek(this.m_vTarget);\r\n      force.add(seek.x, seek.y);\r\n\r\n      if (!this.AccumulateForce(this.m_vSteeringForce, force))\r\n       return new Phaser.Point(this.m_vSteeringForce.x, this.m_vSteeringForce.y);\r\n    }\r\n\r\n    if (this.On(behavior_type.arrive))\r\n    {\r\n      var arrive = this.Arrive(this.m_vTarget, Deceleration.fast);\r\n      force.add(arrive.x, arrive.y);\r\n\r\n      if (!this.AccumulateForce(this.m_vSteeringForce, force))\r\n       return new Phaser.Point(this.m_vSteeringForce.x, this.m_vSteeringForce.y);\r\n    }\r\n\r\n    if (this.On(behavior_type.pursuit))\r\n    {\r\n      var pursuit = this.Pursuit(this.m_pBall);\r\n      force.add(pursuit.x, pursuit.y);\r\n\r\n      if (!this.AccumulateForce(this.m_vSteeringForce, force))\r\n       return new Phaser.Point(this.m_vSteeringForce.x, this.m_vSteeringForce.y);\r\n    }\r\n\r\n    if (this.On(behavior_type.interpose))\r\n    {\r\n      var interpose = this.Interpose(this.m_pBall, this.m_vTarget, this.m_dInterposeDist);\r\n      force.add(interpose.x, interpose.y);\r\n\r\n      if (!this.AccumulateForce(this.m_vSteeringForce, force))\r\n       return new Phaser.Point(this.m_vSteeringForce.x, this.m_vSteeringForce.y);\r\n    }\r\n\r\n    return new Phaser.Point(this.m_vSteeringForce.x, this.m_vSteeringForce.y);\r\n  }\r\n\r\n  //------------------------- ForwardComponent -----------------------------\r\n  //\r\n  //  calculates the forward component of the steering force\r\n  //------------------------------------------------------------------------\r\n  ForwardComponent()\r\n  {\r\n    return this.m_pPlayer.Heading().dot(this.m_vSteeringForce);\r\n  }\r\n\r\n  //--------------------------- SideComponent ------------------------------\r\n  //\r\n  //  //  calculates the side component of the steering force\r\n  //------------------------------------------------------------------------\r\n  SideComponent()\r\n  {\r\n    return this.m_pPlayer.Side().dot(this.m_vSteeringForce) * this.m_pPlayer.MaxTurnRate();\r\n  }\r\n\r\n\r\n  //------------------------------- Seek -----------------------------------\r\n  //\r\n  //  Given a target, this behavior returns a steering force which will\r\n  //  allign the agent with the target and move the agent in the desired\r\n  //  direction\r\n  //------------------------------------------------------------------------\r\n  Seek(target)\r\n  {\r\n    var temppoint = new Phaser.Point(target.x - this.m_pPlayer.Pos().x, target.y - this.m_pPlayer.Pos().y).normalize();\r\n    var DesiredVelocity = new Phaser.Point((temppoint.x * this.m_pPlayer.MaxSpeed()) - this.m_pPlayer.Velocity().x,\r\n     (temppoint.y * this.m_pPlayer.MaxSpeed()) - this.m_pPlayer.Velocity().y);\r\n\r\n    return DesiredVelocity;\r\n  }\r\n\r\n\r\n  //--------------------------- Arrive -------------------------------------\r\n  //\r\n  //  This behavior is similar to seek but it attempts to arrive at the\r\n  //  target with a zero velocity\r\n  //------------------------------------------------------------------------\r\n  Arrive(target, deceleration)\r\n  {\r\n    var ToTarget = new Phaser.Point(target.x - this.m_pPlayer.Pos().x,\r\n     target.y - this.m_pPlayer.Pos().y);\r\n\r\n    //calculate the distance to the target\r\n    var dist = ToTarget.getMagnitude();\r\n\r\n    if (dist > 0)\r\n    {\r\n      //because Deceleration is enumerated as an int, this value is required\r\n      //to provide fine tweaking of the deceleration..\r\n      var DecelerationTweaker = 0.3;\r\n\r\n      //calculate the speed required to reach the target given the desired\r\n      //deceleration\r\n      var speed =  dist / (deceleration * DecelerationTweaker);\r\n\r\n      //make sure the velocity does not exceed the max\r\n      speed = Math.min(speed, this.m_pPlayer.MaxSpeed());\r\n      //from here proceed just like Seek except we don't need to normalize\r\n      //the ToTarget vector because we have already gone to the trouble\r\n      //of calculating its length: dist.\r\n\r\n      var DesiredVelocity =  new Phaser.Point(ToTarget.x * speed / dist, ToTarget.y * speed / dist);\r\n\r\n      var newArrive = new Phaser.Point(DesiredVelocity.x - this.m_pPlayer.Velocity().x,\r\n       DesiredVelocity.y - this.m_pPlayer.Velocity().y);\r\n\r\n      return newArrive;\r\n    }\r\n\r\n    return new Phaser.Point(0, 0);\r\n  }\r\n\r\n\r\n  //------------------------------ Pursuit ---------------------------------\r\n  //\r\n  //  this behavior creates a force that steers the agent towards the\r\n  //  ball\r\n  //------------------------------------------------------------------------\r\n  Pursuit(ball)\r\n  {\r\n    var ToBall = new Phaser.Point(ball.Pos().x - this.m_pPlayer.Pos().x,\r\n     ball.Pos().y - this.m_pPlayer.Pos().y);\r\n\r\n    //the lookahead time is proportional to the distance between the ball\r\n    //and the pursuer;\r\n    var LookAheadTime = 0;\r\n\r\n    if (ball.Speed() != 0)\r\n    {\r\n      LookAheadTime = ToBall.getMagnitude() / ball.Speed();\r\n    }\r\n\r\n    //calculate where the ball will be at this time in the future\r\n    this.m_vTarget = ball.FuturePosition(LookAheadTime);\r\n\r\n    //now seek to the predicted future position of the ball\r\n    return this.Arrive(this.m_vTarget, Deceleration.fast);\r\n  }\r\n\r\n  //-------------------------- FindNeighbours ------------------------------\r\n  //\r\n  //  tags any vehicles within a predefined radius\r\n  //------------------------------------------------------------------------\r\n  FindNeighbours()\r\n  {\r\n    var AllPlayers = ListMembers.GetAllMembers();\r\n\r\n    for (var curPlyr = 0; curPlyr != AllPlayers.length; curPlyr++)\r\n    {\r\n      //first clear any current tag\r\n      AllPlayers[curPlyr].Steering().UnTag();\r\n\r\n      //work in distance squared to avoid sqrts\r\n      var to = new Phaser.Point(AllPlayers[curPlyr].Pos().x -  this.m_pPlayer.Pos().x,\r\n       AllPlayers[curPlyr].Pos().y -  this.m_pPlayer.Pos().y);\r\n\r\n      if (to.getMagnitudeSq() < (this.m_dViewDistance * this.m_dViewDistance))\r\n      {\r\n        AllPlayers[curPlyr].Steering().Tag();\r\n      }\r\n    }//next\r\n  }\r\n\r\n\r\n  //---------------------------- Separation --------------------------------\r\n  //\r\n  // this calculates a force repelling from the other neighbors\r\n  //------------------------------------------------------------------------\r\n  Separation()\r\n  {\r\n    var SteeringForce = new Phaser.Point(0, 0);\r\n    var AllPlayers = ListMembers.GetAllMembers();\r\n\r\n    for (var curPlyr = 0; curPlyr != AllPlayers.length; curPlyr++)\r\n    {\r\n      //make sure this agent isn't included in the calculations and that\r\n      //the agent is close enough\r\n      if ((AllPlayers[curPlyr] !== this.m_pPlayer) && AllPlayers[curPlyr].Steering().Tagged())\r\n      {\r\n        var ToAgentx = this.m_pPlayer.Pos().x - AllPlayers[curPlyr].Pos().x;\r\n        var ToAgenty = this.m_pPlayer.Pos().y - AllPlayers[curPlyr].Pos().y;\r\n\r\n       //scale the force inversely proportional to the agents distance\r\n        //from its neighbor.\r\n        var ToAgent = new Phaser.Point(ToAgentx, ToAgenty);\r\n        var ToAgentnorm = new Phaser.Point(ToAgent.x, ToAgent.y).normalize();\r\n        var addfx = (ToAgentnorm.x / ToAgent.getMagnitude());\r\n        var addfy = (ToAgentnorm.y / ToAgent.getMagnitude());\r\n        SteeringForce.add(addfx, addfy);\r\n      }\r\n    }\r\n\r\n    return SteeringForce;\r\n  }\r\n\r\n  //--------------------------- Interpose ----------------------------------\r\n  //\r\n  //  Given an opponent and an object position this method returns a\r\n  //  force that attempts to position the agent between them\r\n  //------------------------------------------------------------------------\r\n  Interpose(ball, target, DistFromTarget)\r\n  {\r\n    var temp1 = new Phaser.Point(ball.Pos().x - target.x, ball.Pos().y - target.y).normalize();\r\n    var temp2 = new Phaser.Point(target.x + temp1.x * DistFromTarget, target.y + temp1.y * DistFromTarget);\r\n\r\n    return this.Arrive(temp2, Deceleration.normal);\r\n  }\r\n\r\n  RenderAids()\r\n  {\r\n    //render the steering force\r\n    //gdi->RedPen();\r\n\r\n    //gdi->Line(m_pPlayer->Pos(), m_pPlayer->Pos() + m_vSteeringForce * 20);\r\n  }\r\n\r\n  On(bt)\r\n  {\r\n    return (this.m_iFlags & bt) == bt;\r\n  }\r\n\r\n  Force()\r\n  {\r\n    return new Phaser.Point(this.m_vSteeringForce.x, this.m_vSteeringForce.y);\r\n  }\r\n\r\n  Target()\r\n  {\r\n    return new Phaser.Point(this.m_vTarget.x, this.m_vTarget.y);\r\n  }\r\n\r\n  SetTarget(t)\r\n  {\r\n    this.m_vTarget = new Phaser.Point(t.x, t.y);\r\n  }\r\n\r\n  InterposeDistance()\r\n  {\r\n    return this.m_dInterposeDist;\r\n  }\r\n\r\n  SetInterposeDistance(d)\r\n  {\r\n    this.m_dInterposeDist = d;\r\n  }\r\n\r\n  Tagged()\r\n  {\r\n    return this.m_bTagged;\r\n  }\r\n\r\n  Tag()\r\n  {\r\n    this.m_bTagged = true;\r\n  }\r\n\r\n  UnTag()\r\n  {\r\n    this.m_bTagged = false;\r\n  }\r\n\r\n  SeekOn()\r\n  {\r\n    this.m_iFlags |= behavior_type.seek;\r\n  }\r\n\r\n  ArriveOn()\r\n  {\r\n    this.m_iFlags |= behavior_type.arrive;\r\n  }\r\n\r\n  PursuitOn()\r\n  {\r\n    this.m_iFlags |= behavior_type.pursuit;\r\n  }\r\n\r\n  SeparationOn()\r\n  {\r\n    this.m_iFlags |= behavior_type.separation;\r\n  }\r\n\r\n  InterposeOn(d)\r\n  {\r\n    this.m_iFlags |= behavior_type.interpose;\r\n    this.m_dInterposeDist = d;\r\n  }\r\n\r\n  SeekOff()\r\n  {\r\n    if (this.On(behavior_type.seek))\r\n     this.m_iFlags ^= behavior_type.seek;\r\n  }\r\n\r\n  ArriveOff()\r\n  {\r\n    if (this.On(behavior_type.arrive))\r\n     this.m_iFlags ^= behavior_type.arrive;\r\n  }\r\n\r\n  PursuitOff()\r\n  {\r\n    if (this.On(behavior_type.pursuit))\r\n     this.m_iFlags ^= behavior_type.pursuit;\r\n  }\r\n\r\n  SeparationOff()\r\n  {\r\n    if (this.On(behavior_type.separation))\r\n     this.m_iFlags ^= behavior_type.separation;\r\n  }\r\n\r\n  InterposeOff()\r\n  {\r\n    if (this.On(behavior_type.interpose))\r\n     this.m_iFlags ^= behavior_type.interpose;\r\n  }\r\n\r\n  SeekIsOn()\r\n  {\r\n    return this.On(behavior_type.seek);\r\n  }\r\n\r\n  ArriveIsOn()\r\n  {\r\n    return this.On(behavior_type.arrive);\r\n  }\r\n\r\n  PursuitIsOn()\r\n  {\r\n    return this.On(behavior_type.pursuit);\r\n  }\r\n\r\n  SeparationIsOn()\r\n  {\r\n    return this.On(behavior_type.separation);\r\n  }\r\n\r\n  InterposeIsOn()\r\n  {\r\n    return this.On(behavior_type.interpose);\r\n  }\r\n\r\n}\r\n\r\nmodule.exports.SteeringBehaviors = SteeringBehaviors;\r\n","'use strict';\r\n\r\nvar RegulatorExports = require('./Regulator');\r\nvar Regulator = RegulatorExports.Regulator;\r\n\r\nvar ColorTeamExports = require('./ColorTeam');\r\nvar ColorTeam = ColorTeamExports.ColorTeam;\r\n\r\nvar Params = require('./Params');\r\n\r\nclass SupportSpot\r\n{\r\n  constructor(pos, value)\r\n     {\r\n    this.m_vPos = pos;\r\n    this.m_dScore = value;\r\n  }\r\n}\r\n\r\nclass SupportSpotCalculator\r\n{\r\n  // hometeam type SoccerTeam\r\n  constructor(numX, numY, team)\r\n  {\r\n    this.m_Spots = [];\r\n    this.m_pBestSupportingSpot = null;\r\n    this.m_pTeam = team;\r\n\r\n    var PlayingField = team.Pitch().PlayingArea();\r\n\r\n    //calculate the positions of each sweet spot, create them and\r\n    //store them in m_Spots\r\n\r\n    var HeightOfSSRegion = PlayingField.Height() * 0.8;\r\n    var WidthOfSSRegion  = PlayingField.Width() * 0.9;\r\n    var SliceX = WidthOfSSRegion / numX;\r\n    var SliceY = HeightOfSSRegion / numY;\r\n\r\n    var left  = PlayingField.Left() + (PlayingField.Width() - WidthOfSSRegion) / 2.0 + SliceX / 2.0;\r\n    var right = PlayingField.Right() - (PlayingField.Width() - WidthOfSSRegion) / 2.0 - SliceX / 2.0;\r\n    var top   = PlayingField.Top() + (PlayingField.Height() - HeightOfSSRegion) / 2.0 + SliceY / 2.0;\r\n\r\n    for (var x = 0; x < (numX / 2) - 1; ++x)\r\n    {\r\n      for (var y = 0; y < numY; ++y)\r\n      {\r\n        if (this.m_pTeam.Color() == ColorTeam.BLUE)\r\n        {\r\n         this.m_Spots.push(new SupportSpot(new Phaser.Point(left + x * SliceX, top + y * SliceY), 0.0));\r\n         } else\r\n        {\r\n           this.m_Spots.push(new SupportSpot(new Phaser.Point(right - x * SliceX, top + y * SliceY), 0.0));\r\n         }\r\n      }\r\n    }\r\n\r\n    //create the regulator\r\n    this.m_pRegulator = new Regulator(Params.SupportSpotUpdateFreq);\r\n  }\r\n\r\n\r\n  //--------------------------- DetermineBestSupportingPosition -----------------\r\n  //\r\n  //  see header or book for description\r\n  //-----------------------------------------------------------------------------\r\n  DetermineBestSupportingPosition()\r\n  {\r\n    //only update the spots every few frames\r\n    if (!this.m_pRegulator.isReady() && this.m_pBestSupportingSpot)\r\n    {\r\n      return new Phaser.Point(this.m_pBestSupportingSpot.m_vPos.x, this.m_pBestSupportingSpot.m_vPos.y);\r\n    }\r\n\r\n    //reset the best supporting spot\r\n    this.m_pBestSupportingSpot = null;\r\n\r\n    var BestScoreSoFar = 0.0;\r\n\r\n    for (var curSpot = 0; curSpot < this.m_Spots.length; ++curSpot)\r\n    {\r\n      //first remove any previous score. (the score is set to one so that\r\n      //the viewer can see the positions of all the spots if he has the\r\n      //aids turned on)\r\n      this.m_Spots[curSpot].m_dScore = 1.0;\r\n\r\n      //Test 1. is it possible to make a safe pass from the ball's position\r\n      //to this position?\r\n      if (this.m_pTeam.isPassSafeFromAllOpponents(this.m_pTeam.ControllingPlayer().Pos(),\r\n                  this.m_Spots[curSpot].m_vPos,\r\n                  null,\r\n                  Params.MaxPassingForce))\r\n      {\r\n        this.m_Spots[curSpot].m_dScore += Params.Spot_PassSafeScore;\r\n      }\r\n\r\n\r\n      //Test 2. Determine if a goal can be scored from this position.\r\n      var ret_canshoot = this.m_pTeam.CanShoot(this.m_Spots[curSpot].m_vPos,\r\n             Params.MaxShootingForce);\r\n      if (ret_canshoot[0])\r\n      {\r\n        this.m_Spots[curSpot].m_dScore += Params.Spot_CanScoreFromPositionScore;\r\n      }\r\n\r\n\r\n      //Test 3. calculate how far this spot is away from the controlling\r\n      //player. The further away, the higher the score. Any distances further\r\n      //away than OptimalDistance pixels do not receive a score.\r\n      if (this.m_pTeam.SupportingPlayer())\r\n      {\r\n        var OptimalDistance = 200.0;\r\n\r\n        var dist = this.m_pTeam.ControllingPlayer().Pos().distance(this.m_Spots[curSpot].m_vPos);\r\n\r\n        var temp = Math.abs(OptimalDistance - dist);\r\n\r\n        if (temp < OptimalDistance)\r\n        {\r\n\r\n          //normalize the distance and add it to the score\r\n          this.m_Spots[curSpot].m_dScore += Params.Spot_DistFromControllingPlayerScore *\r\n              (OptimalDistance - temp) / OptimalDistance;\r\n        }\r\n      }\r\n\r\n      //check to see if this spot has the highest score so far\r\n      if (this.m_Spots[curSpot].m_dScore > BestScoreSoFar)\r\n      {\r\n        BestScoreSoFar = this.m_Spots[curSpot].m_dScore;\r\n\r\n        this.m_pBestSupportingSpot = this.m_Spots[curSpot];\r\n      }\r\n\r\n    }\r\n\r\n    return new Phaser.Point(this.m_pBestSupportingSpot.m_vPos.x, this.m_pBestSupportingSpot.m_vPos.y);\r\n  }\r\n\r\n\r\n\r\n\r\n\r\n  //------------------------------- GetBestSupportingSpot -----------------------\r\n  //-----------------------------------------------------------------------------\r\n  GetBestSupportingSpot()\r\n  {\r\n    if (this.m_pBestSupportingSpot)\r\n    {\r\n      return new Phaser.Point(this.m_pBestSupportingSpot.m_vPos.x, this.m_pBestSupportingSpot.m_vPos.y);\r\n    } else\r\n    {\r\n      return this.DetermineBestSupportingPosition();\r\n    }\r\n  }\r\n\r\n  //----------------------------------- Render ----------------------------------\r\n  //-----------------------------------------------------------------------------\r\n  Render()\r\n  {\r\n    for (spt = 0; spt < this.m_Spots[spt].size(); ++spt)\r\n    {\r\n      var bmd = game.add.bitmapData(Params.MAP_SIZE_WIDTH, Params.MAP_SIZE_HEIGHT);\r\n      bmd.ctx.fillStyle = '#808080';\r\n\r\n      bmd.ctx.beginPath();\r\n      bmd.ctx.arc(this.m_Spots[spt].m_vPos.x, this.m_Spots[spt].m_vPos.y, this.m_Spots[spt].m_dScore, 0, Math.PI * 2, true);\r\n      bmd.ctx.closePath();\r\n      bmd.ctx.fill();\r\n\r\n      var sprite = game.add.sprite(0, 0, bmd);\r\n    }\r\n\r\n    if (this.m_pBestSupportingSpot)\r\n    {\r\n      var bmd = game.add.bitmapData(Params.MAP_SIZE_WIDTH, Params.MAP_SIZE_HEIGHT);\r\n      bmd.ctx.fillStyle = '#00FF00';\r\n\r\n      bmd.ctx.beginPath();\r\n      bmd.ctx.arc(this.m_pBestSupportingSpot.m_vPos.x, this.m_pBestSupportingSpot.m_vPos.y, this.m_pBestSupportingSpot.m_dScore, 0, Math.PI * 2, true);\r\n      bmd.ctx.closePath();\r\n      bmd.ctx.fill();\r\n\r\n      var sprite = game.add.sprite(0, 0, bmd);\r\n    }\r\n  }\r\n}\r\n\r\nmodule.exports.SupportSpotCalculator = SupportSpotCalculator;\r\n","'use strict';\r\n\r\nvar ColorTeamExports = require('./ColorTeam');\r\nvar ColorTeam = ColorTeamExports.ColorTeam;\r\n\r\nvar StateExports = require('./State');\r\nvar State = StateExports.State;\r\n\r\nvar TeamSize = 5;\r\n\r\nfunction ChangePlayerHomeRegions(team, NewRegions)\r\n{\r\n  for (var plyr = 0; plyr < TeamSize; ++plyr)\r\n  {\r\n    team.SetPlayerHomeRegion(plyr, NewRegions[plyr]);\r\n  }\r\n}\r\n\r\n//************************************************************************ ATTACKING\r\n\r\nclass Attacking extends State\r\n{\r\n  constructor()\r\n  {\r\n    super('Attacking');\r\n  }\r\n\r\n  Enter(team)\r\n  {\r\n    var BlueRegions = [1, 12, 14, 6, 4];\r\n    var RedRegions = [16, 3, 5, 9, 13];\r\n\r\n    //set up the player's home regions\r\n    if (team.Color() == ColorTeam.BLUE)\r\n    {\r\n      ChangePlayerHomeRegions(team, BlueRegions);\r\n    } else\r\n    {\r\n      ChangePlayerHomeRegions(team, RedRegions);\r\n    }\r\n\r\n    //if a player is in either the Wait or ReturnToHomeRegion states, its\r\n    //steering target must be updated to that of its new home region to enable\r\n    //it to move into the correct position.\r\n    team.UpdateTargetsOfWaitingPlayers();\r\n  }\r\n\r\n  Execute(team)\r\n  {\r\n    //if this team is no longer in control change states\r\n    if (!team.InControl())\r\n    {\r\n      team.GetFSM().ChangeState(new Defending()); return;\r\n    }\r\n    //calculate the best position for any supporting attacker to move to\r\n    team.DetermineBestSupportingPosition();\r\n  }\r\n\r\n  Exit(team)\r\n  {\r\n    //there is no supporting player for defense\r\n    team.SetSupportingPlayer(null);\r\n  }\r\n\r\n  OnMessage(team, telegram)\r\n  {\r\n    return false;\r\n  }\r\n}\r\n\r\n\r\n//************************************************************************ DEFENDING\r\n\r\nclass Defending extends State\r\n{\r\n  constructor()\r\n  {\r\n    super('Defending');\r\n  }\r\n\r\n  Enter(team)\r\n  {\r\n    //these define the home regions for this state of each of the players\r\n    var BlueRegions = [1, 6, 8, 3, 5];\r\n    var RedRegions = [16, 9, 11, 12, 14];\r\n\r\n    //set up the player's home regions\r\n    if (team.Color() == ColorTeam.BLUE)\r\n    {\r\n      ChangePlayerHomeRegions(team, BlueRegions);\r\n    } else\r\n    {\r\n      ChangePlayerHomeRegions(team, RedRegions);\r\n    }\r\n\r\n    //if a player is in either the Wait or ReturnToHomeRegion states, its\r\n    //steering target must be updated to that of its new home region\r\n    team.UpdateTargetsOfWaitingPlayers();\r\n  }\r\n\r\n  Execute(team)\r\n  {\r\n    //if in control change states\r\n    if (team.InControl())\r\n    {\r\n      team.GetFSM().ChangeState(new Attacking()); return;\r\n    }\r\n  }\r\n\r\n  Exit(team) {}\r\n\r\n  OnMessage(team, telegram)\r\n  {\r\n    return false;\r\n  }\r\n}\r\n\r\n\r\n//************************************************************************ KICKOFF\r\nclass PrepareForKickOff extends State\r\n{\r\n  constructor()\r\n  {\r\n    super('PrepareForKickOff');\r\n  }\r\n\r\n  Enter(team)\r\n  {\r\n    //reset key player pointers\r\n    team.SetControllingPlayer(null);\r\n    team.SetSupportingPlayer(null);\r\n    team.SetReceiver(null);\r\n    team.SetPlayerClosestToBall(null);\r\n\r\n    //send Msg_GoHome to each player.\r\n    team.ReturnAllFieldPlayersToHome();\r\n  }\r\n\r\n  Execute(team)\r\n  {\r\n    console.log('PrepareForKickOff');\r\n    //if both teams in position, start the game\r\n    if (team.AllPlayersAtHome() && team.Opponents().AllPlayersAtHome())\r\n    {\r\n      console.log('PrepareForKickOff OK');\r\n      team.GetFSM().ChangeState(new Defending());\r\n    }\r\n  }\r\n\r\n  Exit(team)\r\n  {\r\n    team.Pitch().SetGameOn();\r\n  }\r\n\r\n  OnMessage(team, telegram)\r\n  {\r\n    return false;\r\n  }\r\n}\r\n\r\nmodule.exports.Attacking = Attacking;\r\nmodule.exports.Defending = Defending;\r\nmodule.exports.PrepareForKickOff = PrepareForKickOff;\r\n","'use strict';\r\n\r\nclass Telegram\r\n{\r\n  constructor(time = -1, sender = -1, receiver = -1, msg = -1, info = null)\r\n  {\r\n    this.DispatchTime = time;\r\n    this.Sender = sender;\r\n    this.Receiver = receiver;\r\n    this.Msg = msg;\r\n    this.ExtraInfo = info;\r\n  }\r\n}\r\n\r\nmodule.exports.Telegram = Telegram;\r\n","'use strict';\r\n\r\nclass Transformations\r\n{\r\n  constructor()\r\n  {\r\n  }\r\n\r\n  static PointsSign(heading, target)\r\n  {\r\n    if (heading.y * target.x > heading.x * target.y)\r\n    {\r\n      return -1;\r\n    } else\r\n    {\r\n      return 1;\r\n    }\r\n  }\r\n\r\n  static PointToLocalSpace(point, AgentHeading, AgentSide, AgentPosition)\r\n  {\r\n    //make a copy of the point\r\n    var TransPoint = new Phaser.Point(point.x, point.y);\r\n    var NewTransPoint = new Phaser.Point(0, 0);\r\n\r\n    var matTransform = new Phaser.Matrix;\r\n\r\n    var Tx = AgentPosition.dot(AgentHeading) * -1;\r\n    var Ty = AgentPosition.dot(AgentSide) * -1;\r\n\r\n    matTransform.setTo(AgentHeading.x, AgentSide.x, AgentHeading.y, AgentSide.y, Tx, Ty);\r\n    matTransform.apply(TransPoint, NewTransPoint);\r\n\r\n    return NewTransPoint;\r\n  }\r\n\r\n  static isZero(point)\r\n  {\r\n    return (point.x * point.x + point.y * point.y) < Number.MIN_VALUE;\r\n  }\r\n\r\n  static Truncate(point, max)\r\n  {\r\n    if (point.getMagnitude() > max)\r\n    {\r\n      point.normalize();\r\n\r\n      point.x = point.x * max;\r\n      point.y = point.y * max;\r\n    }\r\n  }\r\n\r\n  static Clamp(arg, minVal, maxVal)\r\n  {\r\n    if (arg < minVal)\r\n    {\r\n      arg = minVal;\r\n    }\r\n\r\n    if (arg > maxVal)\r\n    {\r\n      arg = maxVal;\r\n    }\r\n\r\n    return arg;\r\n  }\r\n\r\n  static Reflect(point, norm)\r\n  {\r\n    var reverse = Transformations.GetReverse(norm);\r\n    point.x = point.x + 2.0 * point.dot(norm) * reverse.x;\r\n    point.y = point.y + 2.0 * point.dot(norm) * reverse.y;\r\n  }\r\n\r\n  static GetReverse(point)\r\n  {\r\n    return new Phaser.Point(-point.x, -point.y);\r\n  }\r\n}\r\n\r\nmodule.exports.Transformations = Transformations;\r\n","'use strict';\r\n\r\nclass Wall2D\r\n{\r\n\r\n  constructor(va, vb)\r\n  {\r\n    Object.defineProperty(this, 'm_vA', {\r\n      value: va,\r\n      writable: false,\r\n      enumerable: true,\r\n      configurable: true,\r\n    });\r\n\r\n    Object.defineProperty(this, 'm_vB', {\r\n        value: vb,\r\n        writable: false,\r\n        enumerable: true,\r\n        configurable: true,\r\n      });\r\n\r\n    this.m_vN = new Phaser.Point(0, 0);\r\n\r\n    this.CalculateNormal();\r\n  }\r\n\r\n  CalculateNormal()\r\n  {\r\n    var newvec = new Phaser.Point(this.m_vB.x - this.m_vA.x, this.m_vB.y - this.m_vA.y);\r\n    var temp = newvec.normalize();\r\n\r\n    this.m_vN.x = -temp.y;\r\n    this.m_vN.y = temp.x;\r\n  }\r\n\r\n  From()  {return this.m_vA;}\r\n\r\n  SetFrom(v) {\r\n    this.m_vA = v; CalculateNormal();\r\n  }\r\n\r\n  To()    {return this.m_vB;}\r\n\r\n  SetTo(v) {\r\n    this.m_vB = v; CalculateNormal();\r\n  }\r\n\r\n  Normal() {return this.m_vN;}\r\n\r\n  SetNormal(n) {this.m_vN = n;}\r\n\r\n  Center() {return (this.m_vA + this.m_vB) / 2.0;}\r\n\r\n  Render(graphics)\r\n  {\r\n    graphics.beginFill(0xFFFFFF);\r\n    graphics.lineStyle(2, 0xFFFFFF, 1);\r\n    graphics.moveTo(this.m_vA.x, this.m_vA.y);\r\n    graphics.lineTo(this.m_vB.x, this.m_vB.y);\r\n    graphics.endFill();\r\n  }\r\n}\r\n\r\nmodule.exports.Wall2D = Wall2D;\r\n","'use strict';\r\n\r\nvar SoccerPitchExports = require('./SoccerPitch');\r\nvar SoccerPitch = SoccerPitchExports.SoccerPitch;\r\n\r\nvar SoccerBallExports = require('./SoccerBall');\r\nvar SoccerBall = SoccerBallExports.SoccerBall;\r\n\r\nvar PrecisionTimerExports = require('./PrecisionTimer');\r\nvar PrecisionTimer = PrecisionTimerExports.PrecisionTimer;\r\n\r\nvar Params = require('./Params');\r\n\r\nclass gameBoot\r\n{\r\n  constructor()\r\n  {\r\n    this.game = new Phaser.Game(Params.GAME_WIDTH, Params.GAME_HEIGHT, Phaser.AUTO, 'phaser-example', { update: this.update, preload: this.preload, create: this.create });\r\n  }\r\n\r\n  preload()\r\n  {\r\n    this.game.load.image('arrow', 'sprites/arrow.png');\r\n    this.game.load.image('ball', 'sprites/Soccer_Ball.png');\r\n  }\r\n\r\n  update()\r\n  {\r\n    /*\r\n    this.pitch.m_cxClient = document.getElementById(\"input_MAP_SIZE_WIDTH\").value;\r\n    this.pitch.m_cyClient = document.getElementById(\"input_MAP_SIZE_HEIGHT\").value;\r\n    this.pitch.m_BallSize = document.getElementById(\"input_BallSize\").value;\r\n    this.pitch.m_BallMass = document.getElementById(\"input_BallMass\").value;\r\n\r\n    if(this.oldm_cxClient != this.pitch.m_cxClient ||\r\n      this.oldm_cyClient != this.pitch.m_cyClient || \r\n       this.oldm_BallSize != this.pitch.m_BallSize || \r\n        this.oldm_BallMass != this.pitch.m_BallMass)\r\n    {\r\n     this.oldm_cxClient = document.getElementById(\"input_MAP_SIZE_WIDTH\").value;\r\n     this.oldm_cyClient = document.getElementById(\"input_MAP_SIZE_HEIGHT\").value;\r\n     this.oldm_BallSize = document.getElementById(\"input_BallSize\").value;\r\n     this.oldm_BallMass = document.getElementById(\"input_BallMass\").value;\r\n     \r\n     //this.pitch.Render(this.game);\r\n    }\r\n    */\r\n\r\n    if (this.timer.ReadyForNextFrame())\r\n    {\r\n      this.pitch.Update(this.game);\r\n    }\r\n  }\r\n\r\n  create()\r\n  {\r\n    this.oldm_cxClient = Params.MAP_SIZE_WIDTH;\r\n    this.oldm_cyClient = Params.MAP_SIZE_HEIGHT;\r\n    this.oldm_BallSize = Params.BallSize;\r\n    this.oldm_BallMass = Params.BallMass;\r\n\r\n    this.timer = new PrecisionTimer(Params.FrameRate);\r\n    this.timer.Start();\r\n\r\n    this.game.physics.startSystem(Phaser.Physics.ARCADE);\r\n\r\n    this.pitch = new SoccerPitch(this.game, Params.MAP_SIZE_WIDTH, Params.MAP_SIZE_HEIGHT);\r\n    this.pitch.Render(this.game);\r\n  }\r\n}\r\n\r\nmodule.exports = gameBoot;\r\n"]}